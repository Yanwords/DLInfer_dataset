{
 "1": {
  "name": "long_description",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/setup.py",
  "lineno": "4",
  "column": "4",
  "context": "ort setup\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(name='algebraic-data-types',\n      version=",
  "context_lines": "from setuptools import setup\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nsetup(name='algebraic-data-types',\n      version='0.2',\n      author='Justin Spahr-Summers',\n",
  "slicing": [
   "with open(\"README.md\", \"r\") as fh:\n",
   "    long_description = fh.read()\n",
   "      long_description=long_description,\n"
  ]
 },
 "2": {
  "name": "any_types",
  "type": "hypothesis.strategies.one_of",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/helpers.py",
  "lineno": "12",
  "column": "0",
  "context": "os.getenv(u'HYPOTHESIS_PROFILE', default='dev'))\n\nany_types = one_of(integers(), text())\n\n\ndef invalidPatternMatch(*args: Any) -> NoReturn:",
  "context_lines": "hypothesis.settings.register_profile(\"ci\", max_examples=1000, deadline=100)\nhypothesis.settings.register_profile(\"dev\", max_examples=100, deadline=50)\nhypothesis.settings.load_profile(\n    os.getenv(u'HYPOTHESIS_PROFILE', default='dev'))\n\nany_types = one_of(integers(), text())\n\n\ndef invalidPatternMatch(*args: Any) -> NoReturn:\n    assert False, 'Pattern matching failed'\n\n\n",
  "slicing": [
   "any_types = one_of(integers(), text())\n"
  ]
 },
 "3": {
  "name": "PATH_TO_TEST_BASE_DIRECTORY",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/tests/helpers.py",
  "lineno": "19",
  "column": "0",
  "context": "rn:\n    assert False, 'Pattern matching failed'\n\n\nPATH_TO_TEST_BASE_DIRECTORY = os.path.dirname(__file__)\n",
  "context_lines": "    os.getenv(u'HYPOTHESIS_PROFILE', default='dev'))\n\nany_types = one_of(integers(), text())\n\n\ndef invalidPatternMatch(*args: Any) -> NoReturn:\n    assert False, 'Pattern matching failed'\n\n\nPATH_TO_TEST_BASE_DIRECTORY = os.path.dirname(__file__)\n",
  "slicing": [
   "PATH_TO_TEST_BASE_DIRECTORY = os.path.dirname(__file__)\n"
  ]
 },
 "4": {
  "name": "_T",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_invalid.py",
  "lineno": "6",
  "column": "0",
  "context": "ic, Optional, TypeVar\n\nfrom adt import Case, adt\n\n_T = TypeVar('_T')\n\ninvalid_defined: bool\n\ntry:\n\n    @adt\n    class I",
  "context_lines": "import unittest\nfrom typing import Generic, Optional, TypeVar\n\nfrom adt import Case, adt\n\n_T = TypeVar('_T')\n\ninvalid_defined: bool\n\ntry:\n\n    @adt\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "    class Invalid(Generic[_T]):\n",
   "        CASE: Case[Optional[_T]] = None\n"
  ]
 },
 "5": {
  "name": "invalid_defined",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_invalid.py",
  "lineno": "8",
  "column": "0",
  "context": "r\n\nfrom adt import Case, adt\n\n_T = TypeVar('_T')\n\ninvalid_defined: bool\n\ntry:\n\n    @adt\n    class Invalid(Generic[_T]):\n  ",
  "context_lines": "import unittest\nfrom typing import Generic, Optional, TypeVar\n\nfrom adt import Case, adt\n\n_T = TypeVar('_T')\n\ninvalid_defined: bool\n\ntry:\n\n    @adt\n    class Invalid(Generic[_T]):\n",
  "slicing": [
   "invalid_defined: bool\n",
   "        self.assertFalse(invalid_defined)\n"
  ]
 },
 "6": {
  "name": "CASE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_invalid.py",
  "lineno": "14",
  "column": "8",
  "context": "\n    @adt\n    class Invalid(Generic[_T]):\n        CASE: Case[Optional[_T]] = None\n\n    invalid_defined = True\nexcept AttributeError ",
  "context_lines": "invalid_defined: bool\n\ntry:\n\n    @adt\n    class Invalid(Generic[_T]):\n        CASE: Case[Optional[_T]] = None\n\n    invalid_defined = True\nexcept AttributeError as e:\n    print(f'Expected failure: {e}')\n",
  "slicing": "        CASE: Case[Optional[_T]] = None\n"
 },
 "7": {
  "name": "invalid_defined",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_invalid.py",
  "lineno": "16",
  "column": "4",
  "context": "T]):\n        CASE: Case[Optional[_T]] = None\n\n    invalid_defined = True\nexcept AttributeError as e:\n    print(f'Expected f",
  "context_lines": "try:\n\n    @adt\n    class Invalid(Generic[_T]):\n        CASE: Case[Optional[_T]] = None\n\n    invalid_defined = True\nexcept AttributeError as e:\n    print(f'Expected failure: {e}')\n    invalid_defined = False\n\n\nclass TestInvalid(unittest.TestCase):\n",
  "slicing": [
   "    invalid_defined = True\n",
   "        self.assertFalse(invalid_defined)\n"
  ]
 },
 "8": {
  "name": "invalid_defined",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_invalid.py",
  "lineno": "19",
  "column": "4",
  "context": "ror as e:\n    print(f'Expected failure: {e}')\n    invalid_defined = False\n\n\nclass TestInvalid(unittest.TestCase):\n    def te",
  "context_lines": "        CASE: Case[Optional[_T]] = None\n\n    invalid_defined = True\nexcept AttributeError as e:\n    print(f'Expected failure: {e}')\n    invalid_defined = False\n\n\nclass TestInvalid(unittest.TestCase):\n    def test_cannotSetDefaultValuesForCases(self) -> None:\n",
  "slicing": [
   "    invalid_defined = False\n",
   "        self.assertFalse(invalid_defined)\n"
  ]
 },
 "9": {
  "name": "_T",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "10",
  "column": "0",
  "context": "type_strategy, tuples)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n\n\n@adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n ",
  "context_lines": "from hypothesis import given\nfrom hypothesis.strategies import (builds, deferred, from_type, integers, just,\n                                   one_of, register_type_strategy, tuples)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n\n\n@adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "class ListADT(Generic[_T]):\n",
   "    CONS: Case[_T, \"ListADT[_T]\"]\n",
   "    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n",
   "    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n",
   "    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n",
   "    def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n"
  ]
 },
 "10": {
  "name": "NIL",
  "type": "adt.Case",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "15",
  "column": "4",
  "context": "eVar('_T')\n\n\n@adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n    CONS: Case[_T, \"ListADT[_T]\"]\n\n\nregister_type_",
  "context_lines": "from tests import helpers\n\n_T = TypeVar('_T')\n\n\n@adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n    CONS: Case[_T, \"ListADT[_T]\"]\n\n\nregister_type_strategy(\n    ListADT,\n    one_of(\n",
  "slicing": "    NIL: Case\n"
 },
 "11": {
  "name": "CONS",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "16",
  "column": "4",
  "context": "adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n    CONS: Case[_T, \"ListADT[_T]\"]\n\n\nregister_type_strategy(\n    ListADT,\n    one_of(",
  "context_lines": "_T = TypeVar('_T')\n\n\n@adt\nclass ListADT(Generic[_T]):\n    NIL: Case\n    CONS: Case[_T, \"ListADT[_T]\"]\n\n\nregister_type_strategy(\n    ListADT,\n    one_of(\n",
  "slicing": "    CONS: Case[_T, \"ListADT[_T]\"]\n"
 },
 "12": {
  "name": "xs",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_list.py",
  "lineno": "29",
  "column": "8",
  "context": "\n    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEq",
  "context_lines": "        builds(ListADT.CONS, integers(),\n               deferred(lambda: from_type(ListADT)))))\n\n\nclass TestList(unittest.TestCase):\n    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "class ListADT(Generic[_T]):\n",
   "    CONS: Case[_T, \"ListADT[_T]\"]\n",
   "        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n",
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"a\")\n",
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"b\")\n",
   "        self.assertEqual(xs, ListADT.NIL())\n",
   "    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n",
   "        self.assertEqual(xs, xs)\n",
   "    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n",
   "        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n",
   "    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n",
   "            xs.match()  # type: ignore\n",
   "            xs.match(nil=lambda x: True)  # type: ignore\n",
   "            xs.match(cons=lambda x: True)  # type: ignore\n",
   "    def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n",
   "        if xs.match(nil=lambda: False, cons=lambda x, xs: True):\n",
   "                xs.nil()\n",
   "            self.assertIsNotNone(xs.cons())\n",
   "                xs.cons(),\n",
   "                xs.match(nil=helpers.invalidPatternMatch,\n",
   "                         cons=lambda x, xs: (x, xs)))\n",
   "                xs.cons()\n",
   "                xs.match(nil=lambda: \"foo\", cons=helpers.invalidPatternMatch),\n"
  ]
 },
 "13": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_list.py",
  "lineno": "31",
  "column": "9",
  "context": "(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) ",
  "context_lines": "               deferred(lambda: from_type(ListADT)))))\n\n\nclass TestList(unittest.TestCase):\n    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.assertEqual(xs, ListADT.NIL())\n\n",
  "slicing": [
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"a\")\n",
   "        self.assertEqual(x, \"b\")\n",
   "                         cons=lambda x, xs: (x, xs)))\n"
  ]
 },
 "14": {
  "name": "xs",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_list.py",
  "lineno": "31",
  "column": "12",
  "context": "\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) ",
  "context_lines": "               deferred(lambda: from_type(ListADT)))))\n\n\nclass TestList(unittest.TestCase):\n    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.assertEqual(xs, ListADT.NIL())\n\n",
  "slicing": [
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"a\")\n",
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"b\")\n",
   "        self.assertEqual(xs, ListADT.NIL())\n",
   "        self.assertEqual(xs, xs)\n",
   "        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n",
   "            xs.match()  # type: ignore\n",
   "            xs.match(nil=lambda x: True)  # type: ignore\n",
   "            xs.match(cons=lambda x: True)  # type: ignore\n",
   "        if xs.match(nil=lambda: False, cons=lambda x, xs: True):\n",
   "                xs.nil()\n",
   "            self.assertIsNotNone(xs.cons())\n",
   "                xs.cons(),\n",
   "                xs.match(nil=helpers.invalidPatternMatch,\n",
   "                         cons=lambda x, xs: (x, xs)))\n",
   "                xs.cons()\n",
   "                xs.match(nil=lambda: \"foo\", cons=helpers.invalidPatternMatch),\n"
  ]
 },
 "15": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_list.py",
  "lineno": "34",
  "column": "9",
  "context": "cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.asse",
  "context_lines": "    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.assertEqual(xs, ListADT.NIL())\n\n    @given(from_type(ListADT))\n    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n",
  "slicing": [
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"b\")\n",
   "                         cons=lambda x, xs: (x, xs)))\n"
  ]
 },
 "16": {
  "name": "xs",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_list.py",
  "lineno": "34",
  "column": "12",
  "context": "s()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.asse",
  "context_lines": "    def test_construction(self) -> None:\n        xs = ListADT.CONS(\"a\", ListADT.CONS(\"b\", ListADT.NIL()))\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"a\")\n\n        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.assertEqual(xs, ListADT.NIL())\n\n    @given(from_type(ListADT))\n    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n",
  "slicing": [
   "        (x, xs) = xs.cons()\n",
   "        self.assertEqual(x, \"b\")\n",
   "        self.assertEqual(xs, ListADT.NIL())\n",
   "        self.assertEqual(xs, xs)\n",
   "        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n",
   "            xs.match()  # type: ignore\n",
   "            xs.match(nil=lambda x: True)  # type: ignore\n",
   "            xs.match(cons=lambda x: True)  # type: ignore\n",
   "        if xs.match(nil=lambda: False, cons=lambda x, xs: True):\n",
   "                xs.nil()\n",
   "            self.assertIsNotNone(xs.cons())\n",
   "                xs.cons(),\n",
   "                xs.match(nil=helpers.invalidPatternMatch,\n",
   "                         cons=lambda x, xs: (x, xs)))\n",
   "                xs.cons()\n",
   "                xs.match(nil=lambda: \"foo\", cons=helpers.invalidPatternMatch),\n"
  ]
 },
 "17": {
  "name": "_T",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "7",
  "column": "0",
  "context": "s\nfrom typing import Callable, Optional, TypeVar\n\n_T = TypeVar('_T')\n\n\ndef optionality(x: _T) -> Optional[_T]:\n    retu",
  "context_lines": "import unittest\n\nfrom adt import Case, adt\nfrom tests import helpers\nfrom typing import Callable, Optional, TypeVar\n\n_T = TypeVar('_T')\n\n\ndef optionality(x: _T) -> Optional[_T]:\n    return x\n\n\n@adt\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n"
  ]
 },
 "18": {
  "name": "INTVALUE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "16",
  "column": "4",
  "context": "   return x\n\n\n@adt\nclass OverriddenAccessors:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    @property\n    def int",
  "context_lines": "def optionality(x: _T) -> Optional[_T]:\n    return x\n\n\n@adt\nclass OverriddenAccessors:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    @property\n    def intvalue(self) -> Optional[int]:\n        return self.match(intvalue=lambda x: optionality(x),\n",
  "slicing": "    INTVALUE: Case[int]\n"
 },
 "19": {
  "name": "STRVALUE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "17",
  "column": "4",
  "context": " OverriddenAccessors:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    @property\n    def intvalue(self) -> Optional[",
  "context_lines": "    return x\n\n\n@adt\nclass OverriddenAccessors:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    @property\n    def intvalue(self) -> Optional[int]:\n        return self.match(intvalue=lambda x: optionality(x),\n",
  "slicing": "    STRVALUE: Case[str]\n"
 },
 "20": {
  "name": "INTVALUE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "32",
  "column": "4",
  "context": "optionality(x))\n\n\n@adt\nclass OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intva",
  "context_lines": "        return self.match(intvalue=lambda _: None,\n                          strvalue=lambda x: optionality(x))\n\n\n@adt\nclass OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n",
  "slicing": "    INTVALUE: Case[int]\n"
 },
 "21": {
  "name": "STRVALUE",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "33",
  "column": "4",
  "context": "lass OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str",
  "context_lines": "                          strvalue=lambda x: optionality(x))\n\n\n@adt\nclass OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n",
  "slicing": "    STRVALUE: Case[str]\n"
 },
 "22": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "38",
  "column": "12",
  "context": "ble[[str], str]) -> str:\n        try:\n            x = self.intvalue()\n        except:\n            return strvalue(self.s",
  "context_lines": "    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n            x = self.intvalue()\n        except:\n            return strvalue(self.strvalue())\n\n        return intvalue(x)\n\n\nclass TestOverrides(unittest.TestCase):\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "            x = self.intvalue()\n",
   "        return intvalue(x)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "23": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "47",
  "column": "8",
  "context": "overriddenAccessorIntvalue(self) -> None:\n        x = OverriddenAccessors.INTVALUE(5)\n        self.assertEqual(x.intvalue, 5)\n        se",
  "context_lines": "            return strvalue(self.strvalue())\n\n        return intvalue(x)\n\n\nclass TestOverrides(unittest.TestCase):\n    def test_overriddenAccessorIntvalue(self) -> None:\n        x = OverriddenAccessors.INTVALUE(5)\n        self.assertEqual(x.intvalue, 5)\n        self.assertIsNone(x.strvalue)\n        self.assertEqual(\n            x.match(intvalue=lambda x: x,\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n",
   "    def intvalue(self) -> Optional[int]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "    def strvalue(self) -> Optional[str]:\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "            x = self.intvalue()\n",
   "            return strvalue(self.strvalue())\n",
   "        return intvalue(x)\n",
   "        x = OverriddenAccessors.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "24": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "55",
  "column": "8",
  "context": "overriddenAccessorStrvalue(self) -> None:\n        x = OverriddenAccessors.STRVALUE(\"foobar\")\n        self.assertIsNone(x.intvalue)\n        self",
  "context_lines": "        self.assertEqual(\n            x.match(intvalue=lambda x: x,\n                    strvalue=helpers.invalidPatternMatch), 5)\n\n    def test_overriddenAccessorStrvalue(self) -> None:\n        x = OverriddenAccessors.STRVALUE(\"foobar\")\n        self.assertIsNone(x.intvalue)\n        self.assertEqual(x.strvalue, \"foobar\")\n        self.assertEqual(\n            x.match(intvalue=helpers.invalidPatternMatch,\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n",
   "    def intvalue(self) -> Optional[int]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "    def strvalue(self) -> Optional[str]:\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "            x = self.intvalue()\n",
   "            return strvalue(self.strvalue())\n",
   "        return intvalue(x)\n",
   "        x = OverriddenAccessors.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        x = OverriddenAccessors.STRVALUE(\"foobar\")\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "25": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "63",
  "column": "8",
  "context": "st_overriddenMatchIntvalue(self) -> None:\n        x = OverriddenMatch.INTVALUE(5)\n        self.assertEqual(x.intvalue(), 5)\n        ",
  "context_lines": "        self.assertEqual(\n            x.match(intvalue=helpers.invalidPatternMatch,\n                    strvalue=lambda x: x), \"foobar\")\n\n    def test_overriddenMatchIntvalue(self) -> None:\n        x = OverriddenMatch.INTVALUE(5)\n        self.assertEqual(x.intvalue(), 5)\n        self.assertEqual(\n            x.match(intvalue=lambda x: str(x),\n                    strvalue=helpers.invalidPatternMatch), \"5\")\n\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n",
   "    def intvalue(self) -> Optional[int]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "    def strvalue(self) -> Optional[str]:\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "            x = self.intvalue()\n",
   "            return strvalue(self.strvalue())\n",
   "        return intvalue(x)\n",
   "        x = OverriddenAccessors.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        x = OverriddenAccessors.STRVALUE(\"foobar\")\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        x = OverriddenMatch.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "26": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "70",
  "column": "8",
  "context": "st_overriddenMatchStrvalue(self) -> None:\n        x = OverriddenMatch.STRVALUE(\"foobar\")\n        self.assertEqual(x.strvalue(), \"foobar\")\n ",
  "context_lines": "        self.assertEqual(\n            x.match(intvalue=lambda x: str(x),\n                    strvalue=helpers.invalidPatternMatch), \"5\")\n\n    def test_overriddenMatchStrvalue(self) -> None:\n        x = OverriddenMatch.STRVALUE(\"foobar\")\n        self.assertEqual(x.strvalue(), \"foobar\")\n        self.assertEqual(\n            x.match(intvalue=helpers.invalidPatternMatch,\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "def optionality(x: _T) -> Optional[_T]:\n",
   "    def intvalue(self) -> Optional[int]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "    def strvalue(self) -> Optional[str]:\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "            x = self.intvalue()\n",
   "            return strvalue(self.strvalue())\n",
   "        return intvalue(x)\n",
   "        x = OverriddenAccessors.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        x = OverriddenAccessors.STRVALUE(\"foobar\")\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        x = OverriddenMatch.INTVALUE(5)\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        x = OverriddenMatch.STRVALUE(\"foobar\")\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "        self.assertEqual(\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "27": {
  "name": "_T",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "10",
  "column": "0",
  "context": "egister_type_strategy)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T])",
  "context_lines": "from hypothesis import given\nfrom hypothesis.strategies import (builds, from_type, just, one_of,\n                                   register_type_strategy)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "class ListADT(Generic[_T]):\n",
   "    CONS: Case[_T, \"ListADT[_T]\"]\n",
   "    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n",
   "    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n",
   "    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n",
   "    def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n"
  ]
 },
 "28": {
  "name": "_U",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "11",
  "column": "0",
  "context": "gy)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case",
  "context_lines": "from hypothesis.strategies import (builds, from_type, just, one_of,\n                                   register_type_strategy)\nfrom tests import helpers\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n",
  "slicing": [
   "_U = TypeVar('_U')\n",
   "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n"
  ]
 },
 "29": {
  "name": "NOTHING",
  "type": "adt.Case",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "16",
  "column": "4",
  "context": "ypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable",
  "context_lines": "_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: Maybe.JUST(fn(x)),\n                          nothing=lambda: Maybe.NOTHING())\n\n",
  "slicing": "    NOTHING: Case\n"
 },
 "30": {
  "name": "JUST",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "17",
  "column": "4",
  "context": "t\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"May",
  "context_lines": "_U = TypeVar('_U')\n\n\n@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: Maybe.JUST(fn(x)),\n                          nothing=lambda: Maybe.NOTHING())\n\n",
  "slicing": "    JUST: Case[_T]\n"
 },
 "31": {
  "name": "nothings",
  "type": "hypothesis.strategies.builds",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "28",
  "column": "0",
  "context": "               nothing=lambda: Maybe.NOTHING())\n\n\nnothings = builds(Maybe.NOTHING)\njusts = builds(Maybe.JUST, helpers.any_types)\n\nreg",
  "context_lines": "                          nothing=lambda: Maybe.NOTHING())\n\n    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: fn(x),\n                          nothing=lambda: Maybe.NOTHING())\n\n\nnothings = builds(Maybe.NOTHING)\njusts = builds(Maybe.JUST, helpers.any_types)\n\nregister_type_strategy(Maybe, one_of(nothings, justs))\n\n\nclass TestMaybe(unittest.TestCase):\n    @given(from_type(Maybe))\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "class Maybe(Generic[_T]):\n",
   "    JUST: Case[_T]\n",
   "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n",
   "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n",
   "nothings = builds(Maybe.NOTHING)\n",
   "register_type_strategy(Maybe, one_of(nothings, justs))\n",
   "    def test_equalsItself(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapJust(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n"
  ]
 },
 "32": {
  "name": "justs",
  "type": "hypothesis.strategies.builds",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "29",
  "column": "0",
  "context": "ybe.NOTHING())\n\n\nnothings = builds(Maybe.NOTHING)\njusts = builds(Maybe.JUST, helpers.any_types)\n\nregister_type_strategy(Maybe, one_of(nothings, ju",
  "context_lines": "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: fn(x),\n                          nothing=lambda: Maybe.NOTHING())\n\n\nnothings = builds(Maybe.NOTHING)\njusts = builds(Maybe.JUST, helpers.any_types)\n\nregister_type_strategy(Maybe, one_of(nothings, justs))\n\n\nclass TestMaybe(unittest.TestCase):\n    @given(from_type(Maybe))\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "class Maybe(Generic[_T]):\n",
   "    JUST: Case[_T]\n",
   "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n",
   "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n",
   "justs = builds(Maybe.JUST, helpers.any_types)\n",
   "register_type_strategy(Maybe, one_of(nothings, justs))\n",
   "    def test_equalsItself(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(justs)\n",
   "    def test_mapJust(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(justs)\n",
   "    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n"
  ]
 },
 "33": {
  "name": "mapped",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "45",
  "column": "8",
  "context": "turnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.NOTHING())\n",
  "context_lines": "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.map(lambda x: x), m)\n\n    @given(nothings)\n    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.NOTHING())\n\n    @given(justs)\n    def test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "class Maybe(Generic[_T]):\n",
   "    JUST: Case[_T]\n",
   "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n",
   "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n",
   "nothings = builds(Maybe.NOTHING)\n",
   "justs = builds(Maybe.JUST, helpers.any_types)\n",
   "register_type_strategy(Maybe, one_of(nothings, justs))\n",
   "    def test_equalsItself(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "        mapped = m.map(lambda _: \"foobar\")\n",
   "        self.assertEqual(mapped, Maybe.NOTHING())\n",
   "    @given(justs)\n",
   "    def test_mapJust(self, m: Maybe[_T]) -> None:\n",
   "        self.assertEqual(mapped, Maybe.JUST(\"foobar\"))\n",
   "    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(justs)\n",
   "    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n"
  ]
 },
 "34": {
  "name": "mapped",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "50",
  "column": "8",
  "context": "test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.JUST(\"fooba",
  "context_lines": "        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.NOTHING())\n\n    @given(justs)\n    def test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.JUST(\"foobar\"))\n\n    @given(from_type(Maybe))\n    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda x: Maybe.JUST(x)), m)\n\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "class Maybe(Generic[_T]):\n",
   "    JUST: Case[_T]\n",
   "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n",
   "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n",
   "nothings = builds(Maybe.NOTHING)\n",
   "justs = builds(Maybe.JUST, helpers.any_types)\n",
   "register_type_strategy(Maybe, one_of(nothings, justs))\n",
   "    def test_equalsItself(self, m: Maybe[_T]) -> None:\n",
   "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "        mapped = m.map(lambda _: \"foobar\")\n",
   "        self.assertEqual(mapped, Maybe.NOTHING())\n",
   "    @given(justs)\n",
   "    def test_mapJust(self, m: Maybe[_T]) -> None:\n",
   "        mapped = m.map(lambda _: \"foobar\")\n",
   "        self.assertEqual(mapped, Maybe.JUST(\"foobar\"))\n",
   "    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n",
   "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(nothings)\n",
   "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n",
   "    @given(justs)\n",
   "    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n"
  ]
 },
 "35": {
  "name": "_GENERATED_CODE_FILE_PATH",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "20",
  "column": "0",
  "context": "import List, Iterable\n\nfrom tests import helpers\n\n_GENERATED_CODE_FILE_PATH = os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY,\n                                         \"source_f",
  "context_lines": "import sys\nimport unittest\nfrom typing import List, Iterable\n\nfrom tests import helpers\n\n_GENERATED_CODE_FILE_PATH = os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY,\n                                         \"source_files\",\n                                         \"_generated_readme_code.py\")\n\nIGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n",
  "slicing": [
   "_GENERATED_CODE_FILE_PATH = os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY,\n"
  ]
 },
 "36": {
  "name": "IGNORE_BLOCK_DECORATOR",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "24",
  "column": "0",
  "context": "                    \"_generated_readme_code.py\")\n\nIGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_",
  "context_lines": "from tests import helpers\n\n_GENERATED_CODE_FILE_PATH = os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY,\n                                         \"source_files\",\n                                         \"_generated_readme_code.py\")\n\nIGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n_IMPLICIT_README_IMPORTS = \"\"\"\nfrom typing import Dict, Generic, List, Optional, TypeVar, Tuple, Union\n\"\"\"\n\n\n",
  "slicing": [
   "IGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\n",
   "        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n"
  ]
 },
 "37": {
  "name": "AT_TOP_BLOCK_DECORATOR",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "25",
  "column": "0",
  "context": "_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n_IMPLICIT_README_IMPORTS = \"\"\"\nfrom typing import",
  "context_lines": "_GENERATED_CODE_FILE_PATH = os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY,\n                                         \"source_files\",\n                                         \"_generated_readme_code.py\")\n\nIGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n_IMPLICIT_README_IMPORTS = \"\"\"\nfrom typing import Dict, Generic, List, Optional, TypeVar, Tuple, Union\n\"\"\"\n\n\n",
  "slicing": [
   "AT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n",
   "        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n"
  ]
 },
 "38": {
  "name": "_IMPLICIT_README_IMPORTS",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "27",
  "column": "0",
  "context": "BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n_IMPLICIT_README_IMPORTS = \"\"\"\nfrom typing import Dict, Generic, List, Optional, ",
  "context_lines": "                                         \"source_files\",\n                                         \"_generated_readme_code.py\")\n\nIGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\nAT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n\n_IMPLICIT_README_IMPORTS = \"\"\"\nfrom typing import Dict, Generic, List, Optional, TypeVar, Tuple, Union\n\"\"\"\n\n\ndef extract_code_from_readme() -> str:\n    with open(\n",
  "slicing": [
   "_IMPLICIT_README_IMPORTS = \"\"\"\n",
   "        return _IMPLICIT_README_IMPORTS + _code_blocks_to_str(\n"
  ]
 },
 "39": {
  "name": "code_blocks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "42",
  "column": "4",
  "context": "ist[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_bloc",
  "context_lines": "        return _IMPLICIT_README_IMPORTS + _code_blocks_to_str(\n            _extract_code_blocks_from_file(lines=readme_file_handler))\n\n\ndef _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n",
  "slicing": [
   "    code_blocks: List[List[str]] = []\n",
   "                    code_blocks.insert(0, current_code_block)\n",
   "                    code_blocks.append(current_code_block)\n",
   "    return code_blocks\n",
   "    return \"\".join(itertools.chain.from_iterable(code_blocks))\n"
  ]
 },
 "40": {
  "name": "is_in_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "43",
  "column": "4",
  "context": "E.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_",
  "context_lines": "            _extract_code_blocks_from_file(lines=readme_file_handler))\n\n\ndef _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n",
  "slicing": [
   "    is_in_code_block = False\n",
   "        if not is_in_code_block and line.startswith('```python'):\n",
   "        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n",
   "        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n",
   "        if is_in_code_block and line.startswith('```'):\n",
   "        if is_in_code_block:\n"
  ]
 },
 "41": {
  "name": "current_code_block",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "44",
  "column": "4",
  "context": "[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_b",
  "context_lines": "def _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n        if not is_in_code_block and line.startswith('```python'):\n",
  "slicing": [
   "    current_code_block: List[str] = []\n",
   "                    code_blocks.insert(0, current_code_block)\n",
   "                    code_blocks.append(current_code_block)\n",
   "            current_code_block.append(line)\n"
  ]
 },
 "42": {
  "name": "ignore_next_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "45",
  "column": "4",
  "context": " False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line i",
  "context_lines": "    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n        if not is_in_code_block and line.startswith('```python'):\n            is_in_code_block = True\n",
  "slicing": [
   "    ignore_next_code_block = False\n",
   "            if not ignore_next_code_block:\n"
  ]
 },
 "43": {
  "name": "push_next_block_to_top",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "46",
  "column": "4",
  "context": "[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n        if not is_in_code_",
  "context_lines": "    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n        if not is_in_code_block and line.startswith('```python'):\n            is_in_code_block = True\n",
  "slicing": [
   "    push_next_block_to_top = False\n",
   "                if push_next_block_to_top:\n"
  ]
 },
 "44": {
  "name": "is_in_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "50",
  "column": "12",
  "context": "ock and line.startswith('```python'):\n            is_in_code_block = True\n            continue\n        if not is_in_code_blo",
  "context_lines": "    ignore_next_code_block = False\n    push_next_block_to_top = False\n\n    for line in lines:\n        if not is_in_code_block and line.startswith('```python'):\n            is_in_code_block = True\n            continue\n        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n            ignore_next_code_block = True\n            continue\n",
  "slicing": [
   "            is_in_code_block = True\n",
   "        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n",
   "        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n",
   "        if is_in_code_block and line.startswith('```'):\n",
   "        if is_in_code_block:\n"
  ]
 },
 "45": {
  "name": "ignore_next_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "53",
  "column": "12",
  "context": "e.startswith(IGNORE_BLOCK_DECORATOR):\n            ignore_next_code_block = True\n            continue\n        if not is_in_code_blo",
  "context_lines": "        if not is_in_code_block and line.startswith('```python'):\n            is_in_code_block = True\n            continue\n        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n            ignore_next_code_block = True\n            continue\n        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n            push_next_block_to_top = True\n            continue\n\n",
  "slicing": [
   "            ignore_next_code_block = True\n",
   "            if not ignore_next_code_block:\n"
  ]
 },
 "46": {
  "name": "push_next_block_to_top",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "56",
  "column": "12",
  "context": "e.startswith(AT_TOP_BLOCK_DECORATOR):\n            push_next_block_to_top = True\n            continue\n\n        if is_in_code_block ",
  "context_lines": "        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n            ignore_next_code_block = True\n            continue\n        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n            push_next_block_to_top = True\n            continue\n\n        if is_in_code_block and line.startswith('```'):\n            # End of code block. (Mabye) push it to the block list\n            if not ignore_next_code_block:\n",
  "slicing": [
   "            push_next_block_to_top = True\n",
   "                if push_next_block_to_top:\n"
  ]
 },
 "47": {
  "name": "current_code_block",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "67",
  "column": "12",
  "context": "de_blocks.append(current_code_block)\n\n            current_code_block = []\n            is_in_code_block = False\n            i",
  "context_lines": "                if push_next_block_to_top:\n                    code_blocks.insert(0, current_code_block)\n                else:\n                    code_blocks.append(current_code_block)\n\n            current_code_block = []\n            is_in_code_block = False\n            ignore_next_code_block = False\n            push_next_block_to_top = False\n            continue\n\n",
  "slicing": [
   "            current_code_block = []\n",
   "            current_code_block.append(line)\n"
  ]
 },
 "48": {
  "name": "is_in_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "68",
  "column": "12",
  "context": "\n\n            current_code_block = []\n            is_in_code_block = False\n            ignore_next_code_block = False\n       ",
  "context_lines": "                    code_blocks.insert(0, current_code_block)\n                else:\n                    code_blocks.append(current_code_block)\n\n            current_code_block = []\n            is_in_code_block = False\n            ignore_next_code_block = False\n            push_next_block_to_top = False\n            continue\n\n        if is_in_code_block:\n",
  "slicing": [
   "            is_in_code_block = False\n",
   "        if is_in_code_block:\n"
  ]
 },
 "49": {
  "name": "ignore_next_code_block",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "69",
  "column": "12",
  "context": "\n            is_in_code_block = False\n            ignore_next_code_block = False\n            push_next_block_to_top = False\n       ",
  "context_lines": "                else:\n                    code_blocks.append(current_code_block)\n\n            current_code_block = []\n            is_in_code_block = False\n            ignore_next_code_block = False\n            push_next_block_to_top = False\n            continue\n\n        if is_in_code_block:\n            current_code_block.append(line)\n\n",
  "slicing": "            ignore_next_code_block = False\n"
 },
 "50": {
  "name": "push_next_block_to_top",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "70",
  "column": "12",
  "context": "       ignore_next_code_block = False\n            push_next_block_to_top = False\n            continue\n\n        if is_in_code_block:",
  "context_lines": "                    code_blocks.append(current_code_block)\n\n            current_code_block = []\n            is_in_code_block = False\n            ignore_next_code_block = False\n            push_next_block_to_top = False\n            continue\n\n        if is_in_code_block:\n            current_code_block.append(line)\n\n    return code_blocks\n\n\n",
  "slicing": "            push_next_block_to_top = False\n"
 },
 "51": {
  "name": "temporary_code",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "86",
  "column": "8",
  "context": "the code blocks given in the README.md\"\"\"\n        temporary_code = extract_code_from_readme()\n        globals_for_exec = {\"__name__\": \"README.md",
  "context_lines": "    return \"\".join(itertools.chain.from_iterable(code_blocks))\n\n\nclass TestMyPyPlugin(unittest.TestCase):\n    def test_readmeExamplesAreExecutable(self) -> None:\n        \"\"\"Executing the code blocks given in the README.md\"\"\"\n        temporary_code = extract_code_from_readme()\n        globals_for_exec = {\"__name__\": \"README.md\"}\n\n        try:\n            exec(temporary_code, globals_for_exec)\n        except Exception:\n",
  "slicing": [
   "IGNORE_BLOCK_DECORATOR = '[//]: # (README_TEST:IGNORE)'\n",
   "AT_TOP_BLOCK_DECORATOR = '[//]: # (README_TEST:AT_TOP)'\n",
   "_IMPLICIT_README_IMPORTS = \"\"\"\n",
   "                         \"README.md\")) as readme_file_handler:\n",
   "        return _IMPLICIT_README_IMPORTS + _code_blocks_to_str(\n",
   "            _extract_code_blocks_from_file(lines=readme_file_handler))\n",
   "    code_blocks: List[List[str]] = []\n",
   "    is_in_code_block = False\n",
   "    current_code_block: List[str] = []\n",
   "    ignore_next_code_block = False\n",
   "    push_next_block_to_top = False\n",
   "    for line in lines:\n",
   "        if not is_in_code_block and line.startswith('```python'):\n",
   "            is_in_code_block = True\n",
   "        if not is_in_code_block and line.startswith(IGNORE_BLOCK_DECORATOR):\n",
   "            ignore_next_code_block = True\n",
   "        if not is_in_code_block and line.startswith(AT_TOP_BLOCK_DECORATOR):\n",
   "            push_next_block_to_top = True\n",
   "        if is_in_code_block and line.startswith('```'):\n",
   "            if not ignore_next_code_block:\n",
   "                if push_next_block_to_top:\n",
   "                    code_blocks.insert(0, current_code_block)\n",
   "                    code_blocks.append(current_code_block)\n",
   "            current_code_block = []\n",
   "            is_in_code_block = False\n",
   "            ignore_next_code_block = False\n",
   "            push_next_block_to_top = False\n",
   "        if is_in_code_block:\n",
   "            current_code_block.append(line)\n",
   "    return code_blocks\n",
   "    return \"\".join(itertools.chain.from_iterable(code_blocks))\n",
   "        temporary_code = extract_code_from_readme()\n",
   "            exec(temporary_code, globals_for_exec)\n",
   "            print(temporary_code, file=sys.stderr)\n"
  ]
 },
 "52": {
  "name": "globals_for_exec",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "87",
  "column": "8",
  "context": "mporary_code = extract_code_from_readme()\n        globals_for_exec = {\"__name__\": \"README.md\"}\n\n        try:\n            exec(temporary_code, glo",
  "context_lines": "class TestMyPyPlugin(unittest.TestCase):\n    def test_readmeExamplesAreExecutable(self) -> None:\n        \"\"\"Executing the code blocks given in the README.md\"\"\"\n        temporary_code = extract_code_from_readme()\n        globals_for_exec = {\"__name__\": \"README.md\"}\n\n        try:\n            exec(temporary_code, globals_for_exec)\n        except Exception:\n",
  "slicing": [
   "        globals_for_exec = {\"__name__\": \"README.md\"}\n",
   "            exec(temporary_code, globals_for_exec)\n"
  ]
 },
 "53": {
  "name": "_L",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "10",
  "column": "0",
  "context": "egister_type_strategy)\nfrom tests import helpers\n\n_L = TypeVar('_L')\n_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L,",
  "context_lines": "from hypothesis import given\nfrom hypothesis.strategies import (builds, from_type, one_of,\n                                   register_type_strategy)\nfrom tests import helpers\n\n_L = TypeVar('_L')\n_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n",
  "slicing": [
   "_L = TypeVar('_L')\n",
   "class Either(Generic[_L, _R]):\n",
   "    LEFT: Case[_L]\n",
   "    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n",
   "    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n",
   "    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n",
   "    def test_accessorsConsistentWithMatching(self, e: Either[_L, _R]) -> None:\n"
  ]
 },
 "54": {
  "name": "_R",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "11",
  "column": "0",
  "context": "gy)\nfrom tests import helpers\n\n_L = TypeVar('_L')\n_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Ca",
  "context_lines": "from hypothesis.strategies import (builds, from_type, one_of,\n                                   register_type_strategy)\nfrom tests import helpers\n\n_L = TypeVar('_L')\n_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n",
  "slicing": [
   "_R = TypeVar('_R')\n",
   "class Either(Generic[_L, _R]):\n",
   "    RIGHT: Case[_R]\n",
   "    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n",
   "    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n",
   "    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n",
   "    def test_accessorsConsistentWithMatching(self, e: Either[_L, _R]) -> None:\n"
  ]
 },
 "55": {
  "name": "LEFT",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "16",
  "column": "4",
  "context": "r('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n    RIGHT: Case[_R]\n\n\nregister_type_strategy(\n    ",
  "context_lines": "_L = TypeVar('_L')\n_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n    RIGHT: Case[_R]\n\n\nregister_type_strategy(\n    Either,\n    one_of(builds(Either.LEFT, helpers.any_types),\n",
  "slicing": "    LEFT: Case[_L]\n"
 },
 "56": {
  "name": "RIGHT",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "17",
  "column": "4",
  "context": "s Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n    RIGHT: Case[_R]\n\n\nregister_type_strategy(\n    Either,\n    one_of(b",
  "context_lines": "_R = TypeVar('_R')\n\n\n@adt\nclass Either(Generic[_L, _R]):\n    LEFT: Case[_L]\n    RIGHT: Case[_R]\n\n\nregister_type_strategy(\n    Either,\n    one_of(builds(Either.LEFT, helpers.any_types),\n",
  "slicing": "    RIGHT: Case[_R]\n"
 },
 "57": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "28",
  "column": "8",
  "context": "stCase):\n    def test_left(self) -> None:\n        e: Either[int, str] = Either.LEFT(5)\n        self.assertEqual(e, Either.LEFT(5))\n      ",
  "context_lines": "    one_of(builds(Either.LEFT, helpers.any_types),\n           builds(Either.RIGHT, helpers.any_types)))\n\n\nclass TestEither(unittest.TestCase):\n    def test_left(self) -> None:\n        e: Either[int, str] = Either.LEFT(5)\n        self.assertEqual(e, Either.LEFT(5))\n        self.assertEqual(e.left(), 5)\n\n        self.assertNotEqual(e, Either.RIGHT(5))\n        with self.assertRaises(AttributeError):\n",
  "slicing": [
   "        e: Either[int, str] = Either.LEFT(5)\n",
   "        self.assertEqual(e, Either.LEFT(5))\n",
   "        self.assertEqual(e.left(), 5)\n",
   "        self.assertNotEqual(e, Either.RIGHT(5))\n",
   "            e.right()\n",
   "            e.match(left=lambda n: n + 1, right=helpers.invalidPatternMatch),\n",
   "        self.assertEqual(e, Either.RIGHT(\"foobar\"))\n",
   "        self.assertEqual(e.right(), \"foobar\")\n",
   "        self.assertNotEqual(e, Either.LEFT(\"foobar\"))\n",
   "            e.left()\n",
   "            e.match(left=helpers.invalidPatternMatch, right=lambda s: s + \"z\"),\n",
   "        self.assertEqual(e, e)\n",
   "        self.assertTrue(e.match(left=lambda x: True, right=lambda x: True))\n",
   "            e.match()  # type: ignore\n",
   "            e.match(left=lambda x: True)  # type: ignore\n",
   "            e.match(right=lambda x: True)  # type: ignore\n",
   "        if e.match(left=lambda x: False, right=lambda x: True):\n",
   "            self.assertIsNotNone(e.right())\n",
   "                e.left()\n",
   "                e.right(),\n",
   "                e.match(left=helpers.invalidPatternMatch, right=lambda x: x))\n",
   "            self.assertIsNotNone(e.left())\n",
   "                e.right()\n",
   "                e.left(),\n",
   "                e.match(left=lambda x: x, right=helpers.invalidPatternMatch))\n"
  ]
 },
 "58": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "41",
  "column": "8",
  "context": "    6)\n\n    def test_right(self) -> None:\n        e: Either[int, str] = Either.RIGHT(\"foobar\")\n        self.assertEqual(e, Either.RIGHT(\"foobar\")",
  "context_lines": "        self.assertEqual(\n            e.match(left=lambda n: n + 1, right=helpers.invalidPatternMatch),\n            6)\n\n    def test_right(self) -> None:\n        e: Either[int, str] = Either.RIGHT(\"foobar\")\n        self.assertEqual(e, Either.RIGHT(\"foobar\"))\n        self.assertEqual(e.right(), \"foobar\")\n\n        self.assertNotEqual(e, Either.LEFT(\"foobar\"))\n        with self.assertRaises(AttributeError):\n",
  "slicing": [
   "        e: Either[int, str] = Either.RIGHT(\"foobar\")\n",
   "        self.assertEqual(e, Either.RIGHT(\"foobar\"))\n",
   "        self.assertEqual(e.right(), \"foobar\")\n",
   "        self.assertNotEqual(e, Either.LEFT(\"foobar\"))\n",
   "            e.left()\n",
   "            e.match(left=helpers.invalidPatternMatch, right=lambda s: s + \"z\"),\n",
   "        self.assertEqual(e, e)\n",
   "        self.assertTrue(e.match(left=lambda x: True, right=lambda x: True))\n",
   "            e.match()  # type: ignore\n",
   "            e.match(left=lambda x: True)  # type: ignore\n",
   "            e.match(right=lambda x: True)  # type: ignore\n",
   "        if e.match(left=lambda x: False, right=lambda x: True):\n",
   "            self.assertIsNotNone(e.right())\n",
   "                e.left()\n",
   "                e.right(),\n",
   "                e.match(left=helpers.invalidPatternMatch, right=lambda x: x))\n",
   "            self.assertIsNotNone(e.left())\n",
   "                e.right()\n",
   "                e.left(),\n",
   "                e.match(left=lambda x: x, right=helpers.invalidPatternMatch))\n"
  ]
 },
 "59": {
  "name": "readme_code",
  "type": "tests.test_readme.extract_code_from_readme",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/tests/test_mypy_plugin.py",
  "lineno": "30",
  "column": "8",
  "context": "  def test_readme_examples(self) -> None:\n        readme_code = extract_code_from_readme()\n\n        try:\n            mypy.main.main(script_pa",
  "context_lines": "        # cf. https://github.com/jspahrsummers/adt/issues/26\n        self._call_mypy_on_source_file(\"issue26.py\")\n\n    @unittest.expectedFailure  # Fails because issue #26 is still unfixed\n    def test_readme_examples(self) -> None:\n        readme_code = extract_code_from_readme()\n\n        try:\n            mypy.main.main(script_path=None,\n                           stdout=sys.stdout,\n",
  "slicing": [
   "        readme_code = extract_code_from_readme()\n",
   "                               readme_code,\n"
  ]
 },
 "60": {
  "name": "LITERAL",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue25.py",
  "lineno": "6",
  "column": "4",
  "context": "adt import adt, Case\n\n\n@adt\nclass Expression:\n    LITERAL: Case[float]\n\n\nresult: None = Expression.LITERAL(0.1).match(lit",
  "context_lines": "from adt import adt, Case\n\n\n@adt\nclass Expression:\n    LITERAL: Case[float]\n\n\n",
  "slicing": "    LITERAL: Case[float]\n"
 },
 "61": {
  "name": "result",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue25.py",
  "lineno": "9",
  "column": "0",
  "context": "@adt\nclass Expression:\n    LITERAL: Case[float]\n\n\nresult: None = Expression.LITERAL(0.1).match(literal=lambda n: None)\n",
  "context_lines": "from adt import adt, Case\n\n\n@adt\nclass Expression:\n    LITERAL: Case[float]\n\n\nresult: None = Expression.LITERAL(0.1).match(literal=lambda n: None)\n",
  "slicing": "result: None = Expression.LITERAL(0.1).match(literal=lambda n: None)\n"
 },
 "62": {
  "name": "EMPTY",
  "type": "adt.Case",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue26.py",
  "lineno": "7",
  "column": "4",
  "context": "adt import adt, Case\n\n\n@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, ",
  "context_lines": "from typing import Optional\nfrom adt import adt, Case\n\n\n@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n    def safe_integer(self) -> Optional[int]:\n",
  "slicing": "    EMPTY: Case\n"
 },
 "63": {
  "name": "INTEGER",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue26.py",
  "lineno": "8",
  "column": "4",
  "context": "Case\n\n\n@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n   ",
  "context_lines": "from adt import adt, Case\n\n\n@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n    def safe_integer(self) -> Optional[int]:\n        return self.match(empty=lambda: None,\n",
  "slicing": "    INTEGER: Case[int]\n"
 },
 "64": {
  "name": "STRING_PAIR",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue26.py",
  "lineno": "9",
  "column": "4",
  "context": "leADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n    def safe_integer(self) -> Optio",
  "context_lines": "@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n    def safe_integer(self) -> Optional[int]:\n        return self.match(empty=lambda: None,\n",
  "slicing": "    STRING_PAIR: Case[str, str]\n"
 },
 "65": {
  "name": "CASE0",
  "type": "adt.Case",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue21.py",
  "lineno": "6",
  "column": "4",
  "context": "from adt import adt, Case\n\n\n@adt\nclass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n   ",
  "context_lines": "from adt import adt, Case\n\n\n@adt\nclass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n",
  "slicing": "    CASE0: Case\n"
 },
 "66": {
  "name": "CASE1",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue21.py",
  "lineno": "7",
  "column": "4",
  "context": "t adt, Case\n\n\n@adt\nclass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n    CASE3: Case[str, str",
  "context_lines": "from adt import adt, Case\n\n\n@adt\nclass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n",
  "slicing": "    CASE1: Case[str]\n"
 },
 "67": {
  "name": "CASE2",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue21.py",
  "lineno": "8",
  "column": "4",
  "context": "ass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n    CASE3: Case[str, str, str]\n",
  "context_lines": "@adt\nclass Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n",
  "slicing": "    CASE2: Case[str, str]\n"
 },
 "68": {
  "name": "CASE3",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/source_files/issue21.py",
  "lineno": "9",
  "column": "4",
  "context": "   CASE1: Case[str]\n    CASE2: Case[str, str]\n    CASE3: Case[str, str, str]\n",
  "context_lines": "class Cmd:\n    CASE0: Case\n    CASE1: Case[str]\n    CASE2: Case[str, str]\n    CASE3: Case[str, str, str]\n",
  "slicing": "    CASE3: Case[str, str, str]\n"
 },
 "69": {
  "name": "raw_version",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "34",
  "column": "4",
  "context": "rn plugin class depending on mypy version.\"\"\"\n    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n    assert Decimal(raw_version) >= Decimal(\"0.711\"",
  "context_lines": "from mypy.typevars import fill_typevars\nfrom mypy.util import get_unique_redefinition_name\n\n\ndef plugin(version: str) -> Type[Plugin]:\n    \"\"\"Return plugin class depending on mypy version.\"\"\"\n    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n    assert Decimal(raw_version) >= Decimal(\"0.711\")\n    return ADTPlugin\n\n\n# fullname and name became properties with https://github.com/python/mypy/pull/7829\n# These are compatibility shims\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n"
  ]
 },
 "70": {
  "name": "fn",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "42",
  "column": "4",
  "context": "lname(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.fullname\n    if callable(fn):\n        return typing.cast(st",
  "context_lines": "    return ADTPlugin\n\n\n# fullname and name became properties with https://github.com/python/mypy/pull/7829\n# These are compatibility shims\ndef get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.fullname\n    if callable(fn):\n        return typing.cast(str, fn())\n    return typing.cast(str, fn)\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n"
  ]
 },
 "71": {
  "name": "fn",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "49",
  "column": "4",
  "context": "_name(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.name\n    if callable(fn):\n        return typing.cast(st",
  "context_lines": "    if callable(fn):\n        return typing.cast(str, fn())\n    return typing.cast(str, fn)\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.name\n    if callable(fn):\n        return typing.cast(str, fn())\n    return fn\n\n\nclass ADTPlugin(Plugin):\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n"
  ]
 },
 "72": {
  "name": "_ADT_DECORATOR",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "57",
  "column": "4",
  "context": "(Plugin):\n    # Fully-qualified name for @adt\n    _ADT_DECORATOR = 'adt.decorator.adt'\n\n    def get_type_analyze_hook(\n            self, ",
  "context_lines": "        return typing.cast(str, fn())\n    return fn\n\n\nclass ADTPlugin(Plugin):\n    # Fully-qualified name for @adt\n    _ADT_DECORATOR = 'adt.decorator.adt'\n\n    def get_type_analyze_hook(\n            self, fullname: str\n    ) -> Optional[Callable[[AnalyzeTypeContext], mypy.types.Type]]:\n",
  "slicing": "    _ADT_DECORATOR = 'adt.decorator.adt'\n"
 },
 "73": {
  "name": "api",
  "type": "mypy.plugin.TypeAnalyzerPluginInterface",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "81",
  "column": "4",
  "context": "en removes this type from the ADT completely.\n    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type",
  "context_lines": "    # We do this because the semantic analyzer runs before the class_decorator_hook\n    # gets a chance to remove the Cases. This will convert the type into a valid\n    # runtime type and allows the class_decorator hook to be executed. The hook\n    # then removes this type from the ADT completely.\n    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "74": {
  "name": "type_to_convert",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "82",
  "column": "4",
  "context": "ypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function",
  "context_lines": "    # gets a chance to remove the Cases. This will convert the type into a valid\n    # runtime type and allows the class_decorator hook to be executed. The hook\n    # then removes this type from the ADT completely.\n    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "75": {
  "name": "call_args",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "84",
  "column": "4",
  "context": ": mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"b",
  "context_lines": "    # runtime type and allows the class_decorator hook to be executed. The hook\n    # then removes this type from the ADT completely.\n    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "76": {
  "name": "function_type",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "85",
  "column": "4",
  "context": "xt.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_a",
  "context_lines": "    # then removes this type from the ADT completely.\n    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "77": {
  "name": "arg_types",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "87",
  "column": "4",
  "context": "text.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_",
  "context_lines": "    api: TypeAnalyzerPluginInterface = type_context.api\n    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n\n    return mypy.types.CallableType(\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "78": {
  "name": "arg_kinds",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "88",
  "column": "4",
  "context": "ypes = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    ret",
  "context_lines": "    type_to_convert: mypy.types.UnboundType = type_context.type\n\n    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n\n    return mypy.types.CallableType(\n        arg_types=arg_types,\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "79": {
  "name": "arg_names",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "89",
  "column": "4",
  "context": "nds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstru",
  "context_lines": "    call_args = type_to_convert.args\n    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n\n    return mypy.types.CallableType(\n        arg_types=arg_types,\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "80": {
  "name": "return_type",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "91",
  "column": "4",
  "context": "s]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n\n    return mypy.types.CallableType(\n        arg_t",
  "context_lines": "    function_type = type_context.api.named_type(\"builtins.function\", [])\n\n    arg_types = list(map(api.analyze_type, call_args))\n    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n    arg_names = [None for _ in call_args]\n\n    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n\n    return mypy.types.CallableType(\n        arg_types=arg_types,\n        arg_kinds=arg_kinds,\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "81": {
  "name": "context",
  "type": "mypy.plugin.ClassDefContext",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "103",
  "column": "4",
  "context": "llback=function_type,\n    )\n\n\nclass _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n  ",
  "context_lines": "        ret_type=return_type,\n        fallback=function_type,\n    )\n\n\nclass _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "82": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "104",
  "column": "4",
  "context": "\nclass _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__",
  "context_lines": "        fallback=function_type,\n    )\n\n\nclass _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "83": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "105",
  "column": "4",
  "context": "f:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, ",
  "context_lines": "    )\n\n\nclass _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "84": {
  "name": "t",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "120",
  "column": "8",
  "context": "en(types) != 1:\n            return types\n\n        t = types[0]\n\n        # Explode tuples and replace None with an",
  "context_lines": "    def _normalize_types(types: List[mypy.types.Type]\n                         ) -> List[mypy.types.Type]:\n        if len(types) != 1:\n            return types\n\n        t = types[0]\n\n        # Explode tuples and replace None with an empty list if it's the only\n        # thing provided\n        if isinstance(t, mypy.types.TupleType):\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "85": {
  "name": "argKinds",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "150",
  "column": "8",
  "context": "y.types.Type) -> mypy.types.CallableType:\n        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n        argNames = list(itertools.repeat(None, len",
  "context_lines": "            return mypy.types.TupleType(\n                self.types, self.context.api.named_type('__builtins__.tuple'))\n\n    def match_lambda(self,\n                     return_type: mypy.types.Type) -> mypy.types.CallableType:\n        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n        argNames = list(itertools.repeat(None, len(self.types)))\n\n        return mypy.types.CallableType(\n            self.types, argKinds, argNames, return_type,\n            self.context.api.named_type('__builtins__.function'))\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "86": {
  "name": "argNames",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "151",
  "column": "8",
  "context": "ertools.repeat(ARG_POS, len(self.types)))\n        argNames = list(itertools.repeat(None, len(self.types)))\n\n        return mypy.types.CallableType(\n         ",
  "context_lines": "                self.types, self.context.api.named_type('__builtins__.tuple'))\n\n    def match_lambda(self,\n                     return_type: mypy.types.Type) -> mypy.types.CallableType:\n        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n        argNames = list(itertools.repeat(None, len(self.types)))\n\n        return mypy.types.CallableType(\n            self.types, argKinds, argNames, return_type,\n            self.context.api.named_type('__builtins__.function'))\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "87": {
  "name": "typeStr",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "170",
  "column": "8",
  "context": "types!r})'\n\n    def __str__(self) -> str:\n        typeStr = \", \".join((str(t) for t in self.types))\n        return f'{self.name}: Case[{typeStr}]'\n\n\nd",
  "context_lines": "        return self.name == other.name and self.types == other.types\n\n    def __repr__(self) -> str:\n        return f'_CaseDef(name={self.name}, types={self.types!r})'\n\n    def __str__(self) -> str:\n        typeStr = \", \".join((str(t) for t in self.types))\n        return f'{self.name}: Case[{typeStr}]'\n\n\ndef _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "88": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "175",
  "column": "4",
  "context": "form_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    as",
  "context_lines": "    def __str__(self) -> str:\n        typeStr = \", \".join((str(t) for t in self.types))\n        return f'{self.name}: Case[{typeStr}]'\n\n\ndef _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    assert isinstance(instanceType, mypy.types.Instance)\n\n    cases = _get_and_delete_cases(context)\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "89": {
  "name": "instanceType",
  "type": "mypy.typevars.fill_typevars",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "177",
  "column": "4",
  "context": "ssDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    assert isinstance(instanceType, mypy.types.Ins",
  "context_lines": "        typeStr = \", \".join((str(t) for t in self.types))\n        return f'{self.name}: Case[{typeStr}]'\n\n\ndef _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    assert isinstance(instanceType, mypy.types.Instance)\n\n    cases = _get_and_delete_cases(context)\n    if cases is None:  # Cases were not successfully deleted. We need to defer\n        context.api.defer()\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "90": {
  "name": "cases",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "180",
  "column": "4",
  "context": "sinstance(instanceType, mypy.types.Instance)\n\n    cases = _get_and_delete_cases(context)\n    if cases is None:  # Cases were not successful",
  "context_lines": "def _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    assert isinstance(instanceType, mypy.types.Instance)\n\n    cases = _get_and_delete_cases(context)\n    if cases is None:  # Cases were not successfully deleted. We need to defer\n        context.api.defer()\n        return\n\n    for case in cases:\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "91": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "208",
  "column": "4",
  "context": " is found, return a list of _CaseDef.\n    \"\"\"\n    cls = context.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: Li",
  "context_lines": "    PlaceHolder expression), this function will return None and is expected\n    to be called again.\n\n    If no PlaceHolder is found, return a list of _CaseDef.\n    \"\"\"\n    cls = context.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: List[int] = []\n    for i, statement in enumerate(cls.defs.body):\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "92": {
  "name": "caseDefs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "210",
  "column": "4",
  "context": "t of _CaseDef.\n    \"\"\"\n    cls = context.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: List[int] = []\n    for i, statement i",
  "context_lines": "    to be called again.\n\n    If no PlaceHolder is found, return a list of _CaseDef.\n    \"\"\"\n    cls = context.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: List[int] = []\n    for i, statement in enumerate(cls.defs.body):\n        # Any assignment that doesn't use the new type declaration\n        # syntax can be ignored out of hand.\n",
  "slicing": [
   "    caseDefs: List[_CaseDef] = []\n",
   "        caseDefs.append(\n",
   "    return caseDefs\n"
  ]
 },
 "93": {
  "name": "removed",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "211",
  "column": "4",
  "context": "ontext.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: List[int] = []\n    for i, statement in enumerate(cls.defs.body):\n",
  "context_lines": "    If no PlaceHolder is found, return a list of _CaseDef.\n    \"\"\"\n    cls = context.cls\n\n    caseDefs: List[_CaseDef] = []\n    removed: List[int] = []\n    for i, statement in enumerate(cls.defs.body):\n        # Any assignment that doesn't use the new type declaration\n        # syntax can be ignored out of hand.\n        if not (isinstance(statement, AssignmentStmt)\n",
  "slicing": [
   "    removed: List[int] = []\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n"
  ]
 },
 "94": {
  "name": "lval",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "221",
  "column": "8",
  "context": "e\n        # don't have to worry about it.\n        lval = statement.lvalues[0]\n        if not isinstance(lval, NameExpr):\n       ",
  "context_lines": "                and statement.new_syntax):\n            continue\n\n        # a: int, b: str = 1, 'foo' is not supported syntax so we\n        # don't have to worry about it.\n        lval = statement.lvalues[0]\n        if not isinstance(lval, NameExpr):\n            continue\n\n        sym = cls.info.names.get(lval.name)\n        if sym is None:\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "95": {
  "name": "sym",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "225",
  "column": "8",
  "context": "ce(lval, NameExpr):\n            continue\n\n        sym = cls.info.names.get(lval.name)\n        if sym is None:\n            # This name is",
  "context_lines": "        # don't have to worry about it.\n        lval = statement.lvalues[0]\n        if not isinstance(lval, NameExpr):\n            continue\n\n        sym = cls.info.names.get(lval.name)\n        if sym is None:\n            # This name is likely blocked by a star import. We don't need to defer because\n            # defer() is already called by mark_incomplete().\n            continue\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "96": {
  "name": "var",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "231",
  "column": "8",
  "context": " mark_incomplete().\n            continue\n\n        var = sym.node\n        if isinstance(var, PlaceholderNode):\n     ",
  "context_lines": "        if sym is None:\n            # This name is likely blocked by a star import. We don't need to defer because\n            # defer() is already called by mark_incomplete().\n            continue\n\n        var = sym.node\n        if isinstance(var, PlaceholderNode):\n            # This node is not ready yet.\n            return None\n\n        assert isinstance(var, Var)\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "97": {
  "name": "matchResultType",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "274",
  "column": "4",
  "context": "fContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_typ",
  "context_lines": "                args=[],\n                return_type=case.accessor_return())\n\n\n# `match` method for pattern matching (uses lowercase case names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_type_for_adt_case(context,\n                                          case,\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "98": {
  "name": "caseCallables",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "276",
  "column": "4",
  "context": "Type = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_type_for_adt_case(context,",
  "context_lines": "                return_type=case.accessor_return())\n\n\n# `match` method for pattern matching (uses lowercase case names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_type_for_adt_case(context,\n                                          case,\n                                          resultType=matchResultType)\n        for case in cases\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "99": {
  "name": "matchArgs",
  "type": "list",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "283",
  "column": "4",
  "context": "hResultType)\n        for case in cases\n    }\n\n    matchArgs = [\n        Argument(variable=Var(case.name.lower(), c",
  "context_lines": "                                          case,\n                                          resultType=matchResultType)\n        for case in cases\n    }\n\n    matchArgs = [\n        Argument(variable=Var(case.name.lower(), callableType),\n                 type_annotation=callableType,\n                 initializer=None,\n                 kind=ARG_NAMED)\n",
  "slicing": [
   "    matchArgs = [\n",
   "                args=matchArgs,\n"
  ]
 },
 "100": {
  "name": "typeInfo",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "302",
  "column": "4",
  "context": "     tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}",
  "context_lines": "# Generates a new, unique, unbounded type variable and defines it within the\n# body of the given class.\ndef _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "101": {
  "name": "tVarQualifiedName",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "303",
  "column": "4",
  "context": "s.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtin",
  "context_lines": "# body of the given class.\ndef _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n\n    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "102": {
  "name": "objectType",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "304",
  "column": "4",
  "context": "Name = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifie",
  "context_lines": "def _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n\n    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "103": {
  "name": "tVarExpr",
  "type": "mypy.nodes.TypeVarExpr",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "306",
  "column": "4",
  "context": "ontext.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n    typeInfo.names[tVarName] = SymbolTableNode(MDE",
  "context_lines": "                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n\n    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n                                 objectType)\n\n\n# Determines the Callable type appropriate for destructuring the ADT case\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "104": {
  "name": "callableType",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "318",
  "column": "4",
  "context": "                ) -> mypy.types.CallableType:\n    callableType = case.match_lambda(\n        return_type=mypy.types.TypeVarType(resultT",
  "context_lines": "# described by `case`.\ndef _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.types.TypeVarDef\n                                ) -> mypy.types.CallableType:\n    callableType = case.match_lambda(\n        return_type=mypy.types.TypeVarType(resultType))\n    callableType.variables = [resultType]\n    return callableType\n\n\n# This is mypy.plugins.common.add_method() extended to support class methods.\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "105": {
  "name": "info",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "339",
  "column": "4",
  "context": "\n    \"\"\"Adds a new method to a class.\n    \"\"\"\n    info = ctx.cls.info\n\n    # First remove any previously generated metho",
  "context_lines": "        is_classmethod: bool = False,\n) -> None:\n    \"\"\"Adds a new method to a class.\n    \"\"\"\n    info = ctx.cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid clashes and problems in new semantic analyzer.\n    if name in info.names:\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "106": {
  "name": "sym",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "344",
  "column": "8",
  "context": "ntic analyzer.\n    if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym",
  "context_lines": "    info = ctx.cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid clashes and problems in new semantic analyzer.\n    if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)\n\n    if is_classmethod:\n        first = Argument(\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "107": {
  "name": "first",
  "type": "mypy.nodes.Argument",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "349",
  "column": "8",
  "context": ".remove(sym.node)\n\n    if is_classmethod:\n        first = Argument(\n            Var('cls'),\n            # Working arou",
  "context_lines": "        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)\n\n    if is_classmethod:\n        first = Argument(\n            Var('cls'),\n            # Working around python/mypy#5416.\n            # This should be: mypy.types.TypeType.make_normalized(self_type)\n            mypy.types.AnyType(mypy.types.TypeOfAny.implementation_artifact),\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "108": {
  "name": "args",
  "type": "list",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "360",
  "column": "4",
  "context": "ument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtin",
  "context_lines": "            ARG_POS)\n    else:\n        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "109": {
  "name": "function_type",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "362",
  "column": "4",
  "context": "e, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n",
  "context_lines": "    else:\n        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "110": {
  "name": "arg_types",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "364",
  "column": "4",
  "context": " ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annot",
  "context_lines": "        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(get_name(arg.variable))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "111": {
  "name": "arg_names",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "364",
  "column": "15",
  "context": "med_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annot",
  "context_lines": "        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(get_name(arg.variable))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "112": {
  "name": "arg_kinds",
  "type": "tuple",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "364",
  "column": "26",
  "context": "_builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annot",
  "context_lines": "        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(get_name(arg.variable))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "113": {
  "name": "signature",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "371",
  "column": "4",
  "context": "ariable))\n        arg_kinds.append(arg.kind)\n\n    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n                                        return_typ",
  "context_lines": "        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(get_name(arg.variable))\n        arg_kinds.append(arg.kind)\n\n    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n                                        return_type, function_type)\n    if tvar_def:\n        signature.variables = [tvar_def]\n\n    func = FuncDef(name, args, Block([PassStmt()]))\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "114": {
  "name": "func",
  "type": "mypy.nodes.FuncDef",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "376",
  "column": "4",
  "context": "ef:\n        signature.variables = [tvar_def]\n\n    func = FuncDef(name, args, Block([PassStmt()]))\n    func.info = info\n    func.is_class = is_classm",
  "context_lines": "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n                                        return_type, function_type)\n    if tvar_def:\n        signature.variables = [tvar_def]\n\n    func = FuncDef(name, args, Block([PassStmt()]))\n    func.info = info\n    func.is_class = is_classmethod\n    func.type = set_callable_name(signature, func)\n    func._fullname = get_fullname(info) + '.' + name\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "115": {
  "name": "r_name",
  "type": "mypy.util.get_unique_redefinition_name",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "387",
  "column": "8",
  "context": "        # Get a nice unique name instead.\n        r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n   ",
  "context_lines": "    # NOTE: we would like the plugin generated node to dominate, but we still\n    # need to keep any existing definitions so they get semantically analyzed.\n    if name in info.names:\n        # Get a nice unique name instead.\n        r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    info.defn.defs.body.append(func)\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "116": {
  "name": "self_type",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "357",
  "column": "8",
  "context": "     None,\n            ARG_POS)\n    else:\n        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, N",
  "context_lines": "            mypy.types.AnyType(mypy.types.TypeOfAny.implementation_artifact),\n            None,\n            ARG_POS)\n    else:\n        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "117": {
  "name": "first",
  "type": "mypy.nodes.Argument",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "358",
  "column": "8",
  "context": "f_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ct",
  "context_lines": "            None,\n            ARG_POS)\n    else:\n        self_type = self_type or fill_typevars(info)\n        first = Argument(Var('self'), self_type, None, ARG_POS)\n\n    args = [first] + args\n\n    function_type = ctx.api.named_type('__builtins__.function')\n\n    arg_types, arg_names, arg_kinds = [], [], []\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "118": {
  "name": "_T",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "3",
  "column": "0",
  "context": ", Callable, Generic, Tuple, Type, TypeVar, Union\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\nclass TupleConstructor:\n    d",
  "context_lines": "from typing import TYPE_CHECKING, Any, Callable, Generic, Tuple, Type, TypeVar, Union\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\nclass TupleConstructor:\n    def __init__(self, types: Tuple[Type[Any], ...]):\n        self._types = types\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "                        callback: Callable[..., _T]) -> _T:\n",
   "    def constructCase(self, arg: _T) -> _T:\n",
   "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n",
   "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n",
   "    class CaseT(Generic[_T]):\n",
   "        def __getitem__(self, params: _T) -> CaseT[_T]:\n"
  ]
 },
 "119": {
  "name": "_U",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "4",
  "column": "0",
  "context": ", Tuple, Type, TypeVar, Union\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\nclass TupleConstructor:\n    def __init__(self, t",
  "context_lines": "from typing import TYPE_CHECKING, Any, Callable, Generic, Tuple, Type, TypeVar, Union\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\nclass TupleConstructor:\n    def __init__(self, types: Tuple[Type[Any], ...]):\n        self._types = types\n",
  "slicing": [
   "_U = TypeVar('_U')\n",
   "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n"
  ]
 },
 "120": {
  "name": "typeString",
  "type": "str",
  "class": "build-in",
  "approach": "Pysonar2",
  "file_path": "adt/adt/case.py",
  "lineno": "25",
  "column": "8",
  "context": "lf._types\n\n    def __repr__(self) -> str:\n        typeString = ', '.join((str(t) for t in self._types))\n        return f'Case[{typeString}]'\n\n\nclass Ident",
  "context_lines": "        return callback(*value)\n\n    def getTypes(self) -> Any:\n        return self._types\n\n    def __repr__(self) -> str:\n        typeString = ', '.join((str(t) for t in self._types))\n        return f'Case[{typeString}]'\n\n\nclass IdentityConstructor:\n    def __init__(self, argType: Type[Any]):\n        self._argType = argType\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "                        callback: Callable[..., _T]) -> _T:\n",
   "        typeString = ', '.join((str(t) for t in self._types))\n",
   "        return f'Case[{typeString}]'\n",
   "    def constructCase(self, arg: _T) -> _T:\n",
   "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n",
   "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n",
   "    class CaseT(Generic[_T]):\n",
   "        def __getitem__(self, params: _T) -> CaseT[_T]:\n"
  ]
 },
 "121": {
  "name": "AnyConstructor",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "48",
  "column": "4",
  "context": "se[{self._argType}]'\n\n\nclass CaseConstructor:\n    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n                           TupleConstructor]\n\n    ",
  "context_lines": "        return self._argType\n\n    def __repr__(self) -> str:\n        return f'Case[{self._argType}]'\n\n\nclass CaseConstructor:\n    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n                           TupleConstructor]\n\n    def constructCase(self) -> None:\n        return None\n\n    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "                        callback: Callable[..., _T]) -> _T:\n",
   "        typeString = ', '.join((str(t) for t in self._types))\n",
   "        return f'Case[{typeString}]'\n",
   "    def constructCase(self, arg: _T) -> _T:\n",
   "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n",
   "    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n",
   "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n",
   "                    ) -> AnyConstructor:\n",
   "    class CaseT(Generic[_T]):\n",
   "        def __getitem__(self, params: _T) -> CaseT[_T]:\n"
  ]
 },
 "122": {
  "name": "Case",
  "type": "CaseConstructor",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "85",
  "column": "4",
  "context": "one], metaclass=CaseMeta):\n        pass\nelse:\n    Case = CaseConstructor()\n\n# Case\n# Case[int]\n# Case[int, str]\n\n# class Test",
  "context_lines": "            pass\n\n    class Case(CaseT[None], metaclass=CaseMeta):\n        pass\nelse:\n    Case = CaseConstructor()\n\n# Case\n# Case[int]\n# Case[int, str]\n\n",
  "slicing": [
   "_T = TypeVar('_T')\n",
   "_U = TypeVar('_U')\n",
   "                        callback: Callable[..., _T]) -> _T:\n",
   "        typeString = ', '.join((str(t) for t in self._types))\n",
   "        return f'Case[{typeString}]'\n",
   "    def constructCase(self, arg: _T) -> _T:\n",
   "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n",
   "    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n",
   "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n",
   "                    ) -> AnyConstructor:\n",
   "    class CaseT(Generic[_T]):\n",
   "        def __getitem__(self, params: _T) -> CaseT[_T]:\n",
   "    Case = CaseConstructor()\n"
  ]
 },
 "123": {
  "name": "caseConstructors",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "16",
  "column": "4",
  "context": " # no annotations defined\n        return cls\n\n    caseConstructors = {\n        k: constructor\n        for k, constructor ",
  "context_lines": "        annotations = cls.__annotations__\n    except AttributeError:\n        # no annotations defined\n        return cls\n\n    caseConstructors = {\n        k: constructor\n        for k, constructor in annotations.items() if not k.startswith('__')\n    }\n\n    for k, constructor in caseConstructors.items():\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "124": {
  "name": "annotations",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/decorator.py",
  "lineno": "11",
  "column": "8",
  "context": "r\n\n\n@no_type_check\ndef adt(cls):\n    try:\n        annotations = cls.__annotations__\n    except AttributeError:\n        # no annotation",
  "context_lines": "from adt.case import CaseConstructor\n\n\n@no_type_check\ndef adt(cls):\n    try:\n        annotations = cls.__annotations__\n    except AttributeError:\n        # no annotations defined\n        return cls\n\n    caseConstructors = {\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "125": {
  "name": "accessorName",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/decorator.py",
  "lineno": "111",
  "column": "4",
  "context": "e'\n            )\n\n        return self._value\n\n    accessorName = case.name.lower()\n    if accessorName not in cls.__dict__:\n        s",
  "context_lines": "            raise AttributeError(\n                f'{self} was constructed as case {self._key.name}, so {_case.name.lower()} is not accessible'\n            )\n\n        return self._value\n\n    accessorName = case.name.lower()\n    if accessorName not in cls.__dict__:\n        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "126": {
  "name": "_MatchResult",
  "type": "typing.TypeVar",
  "class": "imported",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "116",
  "column": "0",
  "context": "_:\n        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -",
  "context_lines": "        return self._value\n\n    accessorName = case.name.lower()\n    if accessorName not in cls.__dict__:\n        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "127": {
  "name": "caseNames",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/decorator.py",
  "lineno": "123",
  "column": "8",
  "context": "able[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n        upperKeys = {k: k.upper() for k in kwargs.",
  "context_lines": "def _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n        upperKeys = {k: k.upper() for k in kwargs.keys()}\n\n        for key in upperKeys.values():\n            if key not in caseNames:\n                raise ValueError(\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "128": {
  "name": "upperKeys",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "124",
  "column": "8",
  "context": "    caseNames = _cases.__members__.keys()\n        upperKeys = {k: k.upper() for k in kwargs.keys()}\n\n        for key in upperKeys.values():\n          ",
  "context_lines": "    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n        upperKeys = {k: k.upper() for k in kwargs.keys()}\n\n        for key in upperKeys.values():\n            if key not in caseNames:\n                raise ValueError(\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "129": {
  "name": "upperKey",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "138",
  "column": "12",
  "context": " for key, callback in kwargs.items():\n            upperKey = upperKeys[key]\n\n            if self._key == _cases.__members__[up",
  "context_lines": "            if key not in upperKeys.values():\n                raise ValueError(\n                    f'Incomplete pattern match against {self} (missing {key})')\n\n        for key, callback in kwargs.items():\n            upperKey = upperKeys[key]\n\n            if self._key == _cases.__members__[upperKey]:\n                caseConstructor: CaseConstructor.AnyConstructor = type(\n                    self).__annotations__[upperKey]\n",
  "slicing": [
   "        annotations = cls.__annotations__\n",
   "    caseConstructors = {\n",
   "        for k, constructor in annotations.items() if not k.startswith('__')\n",
   "    for k, constructor in caseConstructors.items():\n",
   "        if not hasattr(constructor, 'constructCase'):\n",
   "                f'Annotation {k} should be a Case[…] constructor, got {constructor!r} instead'\n",
   "        '_Key', list(caseConstructors.keys()))\n",
   "    cls._types = list(x.getTypes() for x in list(caseConstructors.values()))\n",
   "    for caseKey in cls._Key.__members__.values():\n",
   "        _installOneConstructor(cls, caseKey)\n",
   "        _installOneAccessor(cls, caseKey)\n",
   "    setattr(cls, case.name, classmethod(constructor))\n",
   "    accessorName = case.name.lower()\n",
   "    if accessorName not in cls.__dict__:\n",
   "        setattr(cls, accessorName, accessor)\n",
   "_MatchResult = TypeVar('_MatchResult')\n",
   "              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n",
   "        caseNames = _cases.__members__.keys()\n",
   "        upperKeys = {k: k.upper() for k in kwargs.keys()}\n",
   "        for key in upperKeys.values():\n",
   "            if key not in caseNames:\n",
   "                    f'Unrecognized case {key} in pattern match against {self} (expected one of {caseNames})'\n",
   "        for key in caseNames:\n",
   "            if key not in upperKeys.values():\n",
   "                    f'Incomplete pattern match against {self} (missing {key})')\n",
   "        for key, callback in kwargs.items():\n",
   "            upperKey = upperKeys[key]\n",
   "            if self._key == _cases.__members__[upperKey]:\n",
   "                    self).__annotations__[upperKey]\n"
  ]
 },
 "130": {
  "name": "caseConstructor",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/decorator.py",
  "lineno": "141",
  "column": "16",
  "context": " == _cases.__members__[upperKey]:\n                caseConstructor: CaseConstructor.AnyConstructor = type(\n                    self).__annotations__[upperKey",
  "context_lines": "                    f'Incomplete pattern match against {self} (missing {key})')\n\n        for key, callback in kwargs.items():\n            upperKey = upperKeys[key]\n\n            if self._key == _cases.__members__[upperKey]:\n                caseConstructor: CaseConstructor.AnyConstructor = type(\n                    self).__annotations__[upperKey]\n                return caseConstructor.deconstructCase(self._value, callback)\n\n        assert False, 'Execution should not reach here'\n\n    if 'match' not in cls.__dict__:\n",
  "slicing": [
   "                caseConstructor: CaseConstructor.AnyConstructor = type(\n",
   "                return caseConstructor.deconstructCase(self._value, callback)\n"
  ]
 },
 "131": {
  "name": "xs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "39",
  "column": "32",
  "context": "om_type(ListADT))\n    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n        self.assertEqual(xs, xs)\n\n    @given(from_",
  "context_lines": "        (x, xs) = xs.cons()\n        self.assertEqual(x, \"b\")\n        self.assertEqual(xs, ListADT.NIL())\n\n    @given(from_type(ListADT))\n    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n        self.assertEqual(xs, xs)\n\n    @given(from_type(ListADT))\n    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n\n",
  "slicing": "    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n"
 },
 "132": {
  "name": "xs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "43",
  "column": "50",
  "context": "    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n        self.assertTrue(xs.match(nil=lambda: True,",
  "context_lines": "    @given(from_type(ListADT))\n    def test_equalsItself(self, xs: ListADT[_T]) -> None:\n        self.assertEqual(xs, xs)\n\n    @given(from_type(ListADT))\n    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n\n    @given(from_type(ListADT))\n    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n        with self.assertRaises(ValueError):\n",
  "slicing": "    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n"
 },
 "133": {
  "name": "xs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "47",
  "column": "50",
  "context": "    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n        with self.assertRaises(ValueError):\n      ",
  "context_lines": "    @given(from_type(ListADT))\n    def test_exhaustivePatternMatchSucceeds(self, xs: ListADT[_T]) -> None:\n        self.assertTrue(xs.match(nil=lambda: True, cons=lambda x, xs: True))\n\n    @given(from_type(ListADT))\n    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n        with self.assertRaises(ValueError):\n            xs.match()  # type: ignore\n\n        with self.assertRaises(ValueError):\n            xs.match(nil=lambda x: True)  # type: ignore\n\n",
  "slicing": "    def test_inexhaustivePatternMatchThrows(self, xs: ListADT[_T]) -> None:\n"
 },
 "134": {
  "name": "xs",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_list.py",
  "lineno": "58",
  "column": "51",
  "context": "   def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n        if xs.match(nil=lambda: False, cons=lambda",
  "context_lines": "            xs.match(nil=lambda x: True)  # type: ignore\n\n        with self.assertRaises(ValueError):\n            xs.match(cons=lambda x: True)  # type: ignore\n\n    @given(from_type(ListADT))\n    def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n        if xs.match(nil=lambda: False, cons=lambda x, xs: True):\n            with self.assertRaises(AttributeError):\n                xs.nil()\n\n            self.assertIsNotNone(xs.cons())\n",
  "slicing": "    def test_accessorsConsistentWithMatching(self, xs: ListADT[_T]) -> None:\n"
 },
 "135": {
  "name": "x",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "10",
  "column": "16",
  "context": "al, TypeVar\n\n_T = TypeVar('_T')\n\n\ndef optionality(x: _T) -> Optional[_T]:\n    return x\n\n\n@adt\nclass OverriddenAccessors:\n   ",
  "context_lines": "from adt import Case, adt\nfrom tests import helpers\nfrom typing import Callable, Optional, TypeVar\n\n_T = TypeVar('_T')\n\n\ndef optionality(x: _T) -> Optional[_T]:\n    return x\n\n\n@adt\nclass OverriddenAccessors:\n    INTVALUE: Case[int]\n",
  "slicing": [
   "def optionality(x: _T) -> Optional[_T]:\n",
   "        return self.match(intvalue=lambda x: optionality(x),\n",
   "                          strvalue=lambda x: optionality(x))\n",
   "        return intvalue(x)\n",
   "        self.assertEqual(x.intvalue, 5)\n",
   "        self.assertIsNone(x.strvalue)\n",
   "            x.match(intvalue=lambda x: x,\n",
   "        self.assertIsNone(x.intvalue)\n",
   "        self.assertEqual(x.strvalue, \"foobar\")\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n",
   "        self.assertEqual(x.intvalue(), 5)\n",
   "            x.match(intvalue=lambda x: str(x),\n",
   "        self.assertEqual(x.strvalue(), \"foobar\")\n",
   "            x.match(intvalue=helpers.invalidPatternMatch,\n",
   "                    strvalue=lambda x: x), \"foobar\")\n"
  ]
 },
 "136": {
  "name": "intvalue",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "35",
  "column": "20",
  "context": "int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> s",
  "context_lines": "@adt\nclass OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n            x = self.intvalue()\n        except:\n",
  "slicing": "    def match(self, intvalue: Callable[[int], str],\n"
 },
 "137": {
  "name": "strvalue",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_overrides.py",
  "lineno": "36",
  "column": "14",
  "context": "lf, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n            x = self.intvalue()\n     ",
  "context_lines": "class OverriddenMatch:\n    INTVALUE: Case[int]\n    STRVALUE: Case[str]\n\n    def match(self, intvalue: Callable[[int], str],\n              strvalue: Callable[[str], str]) -> str:\n        try:\n            x = self.intvalue()\n        except:\n            return strvalue(self.strvalue())\n\n",
  "slicing": "              strvalue: Callable[[str], str]) -> str:\n"
 },
 "138": {
  "name": "fn",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "19",
  "column": "18",
  "context": "THING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: Maybe.JUS",
  "context_lines": "@adt\nclass Maybe(Generic[_T]):\n    NOTHING: Case\n    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: Maybe.JUST(fn(x)),\n                          nothing=lambda: Maybe.NOTHING())\n\n    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: fn(x),\n",
  "slicing": "    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n"
 },
 "139": {
  "name": "fn",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "23",
  "column": "22",
  "context": "g=lambda: Maybe.NOTHING())\n\n    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: fn(x),\n  ",
  "context_lines": "    JUST: Case[_T]\n\n    def map(self, fn: Callable[[_T], _U]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: Maybe.JUST(fn(x)),\n                          nothing=lambda: Maybe.NOTHING())\n\n    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n        return self.match(just=lambda x: fn(x),\n                          nothing=lambda: Maybe.NOTHING())\n\n\nnothings = builds(Maybe.NOTHING)\njusts = builds(Maybe.JUST, helpers.any_types)\n\n",
  "slicing": "    def flatMap(self, fn: Callable[[_T], \"Maybe[_U]\"]) -> \"Maybe[_U]\":\n"
 },
 "140": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "36",
  "column": "32",
  "context": "from_type(Maybe))\n    def test_equalsItself(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m, m)\n\n    @given(from_ty",
  "context_lines": "justs = builds(Maybe.JUST, helpers.any_types)\n\nregister_type_strategy(Maybe, one_of(nothings, justs))\n\n\nclass TestMaybe(unittest.TestCase):\n    @given(from_type(Maybe))\n    def test_equalsItself(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m, m)\n\n    @given(from_type(Maybe))\n    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.map(lambda x: x), m)\n\n",
  "slicing": "    def test_equalsItself(self, m: Maybe[_T]) -> None:\n"
 },
 "141": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "40",
  "column": "31",
  "context": "(from_type(Maybe))\n    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.map(lambda x: x), m)\n\n ",
  "context_lines": "    @given(from_type(Maybe))\n    def test_equalsItself(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m, m)\n\n    @given(from_type(Maybe))\n    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.map(lambda x: x), m)\n\n    @given(nothings)\n    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n",
  "slicing": "    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n"
 },
 "142": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "44",
  "column": "44",
  "context": "ings)\n    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n       ",
  "context_lines": "    @given(from_type(Maybe))\n    def test_mapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.map(lambda x: x), m)\n\n    @given(nothings)\n    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.NOTHING())\n\n    @given(justs)\n    def test_mapJust(self, m: Maybe[_T]) -> None:\n",
  "slicing": "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n"
 },
 "143": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "49",
  "column": "27",
  "context": "())\n\n    @given(justs)\n    def test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n       ",
  "context_lines": "    def test_mapNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.NOTHING())\n\n    @given(justs)\n    def test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.JUST(\"foobar\"))\n\n    @given(from_type(Maybe))\n    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n",
  "slicing": "    def test_mapJust(self, m: Maybe[_T]) -> None:\n"
 },
 "144": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "54",
  "column": "35",
  "context": "m_type(Maybe))\n    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda x: Maybe",
  "context_lines": "    def test_mapJust(self, m: Maybe[_T]) -> None:\n        mapped = m.map(lambda _: \"foobar\")\n        self.assertEqual(mapped, Maybe.JUST(\"foobar\"))\n\n    @given(from_type(Maybe))\n    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda x: Maybe.JUST(x)), m)\n\n    @given(from_type(Maybe))\n    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.NOTHING()), Maybe.NOTHING())\n\n",
  "slicing": "    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n"
 },
 "145": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "58",
  "column": "50",
  "context": "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe",
  "context_lines": "    @given(from_type(Maybe))\n    def test_flatMapIdentity(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda x: Maybe.JUST(x)), m)\n\n    @given(from_type(Maybe))\n    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.NOTHING()), Maybe.NOTHING())\n\n    @given(nothings)\n    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.JUST(\"foobar\")),\n",
  "slicing": "    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n"
 },
 "146": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "62",
  "column": "50",
  "context": "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe",
  "context_lines": "    @given(from_type(Maybe))\n    def test_flatMapToNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.NOTHING()), Maybe.NOTHING())\n\n    @given(nothings)\n    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.JUST(\"foobar\")),\n                         Maybe.NOTHING())\n\n    @given(justs)\n    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n",
  "slicing": "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n"
 },
 "147": {
  "name": "m",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_maybe.py",
  "lineno": "67",
  "column": "33",
  "context": "   @given(justs)\n    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe",
  "context_lines": "    def test_flatMapOfNothingReturnsNothing(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.JUST(\"foobar\")),\n                         Maybe.NOTHING())\n\n    @given(justs)\n    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n        self.assertEqual(m.flatMap(lambda _: Maybe.JUST(\"foobar\")),\n",
  "slicing": "    def test_flatMapOfJust(self, m: Maybe[_T]) -> None:\n"
 },
 "148": {
  "name": "lines",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "40",
  "column": "35",
  "context": "le_handler))\n\n\ndef _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: Lis",
  "context_lines": "            os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY, \"..\",\n                         \"README.md\")) as readme_file_handler:\n        return _IMPLICIT_README_IMPORTS + _code_blocks_to_str(\n            _extract_code_blocks_from_file(lines=readme_file_handler))\n\n\ndef _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n    \"\"\"Parse the README.md\"\"\"\n    code_blocks: List[List[str]] = []\n    is_in_code_block = False\n    current_code_block: List[str] = []\n",
  "slicing": "def _extract_code_blocks_from_file(lines: Iterable[str]) -> List[List[str]]:\n"
 },
 "149": {
  "name": "code_blocks",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_readme.py",
  "lineno": "79",
  "column": "24",
  "context": "\n    return code_blocks\n\n\ndef _code_blocks_to_str(code_blocks: Iterable[Iterable[str]]) -> str:\n    return \"\".join(itertools.chain.from_iterable(c",
  "context_lines": "            continue\n\n        if is_in_code_block:\n            current_code_block.append(line)\n\n    return code_blocks\n\n\ndef _code_blocks_to_str(code_blocks: Iterable[Iterable[str]]) -> str:\n    return \"\".join(itertools.chain.from_iterable(code_blocks))\n\n\nclass TestMyPyPlugin(unittest.TestCase):\n    def test_readmeExamplesAreExecutable(self) -> None:\n        \"\"\"Executing the code blocks given in the README.md\"\"\"\n",
  "slicing": "def _code_blocks_to_str(code_blocks: Iterable[Iterable[str]]) -> str:\n"
 },
 "150": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "54",
  "column": "32",
  "context": "rom_type(Either))\n    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n        self.assertEqual(e, e)\n\n    @given(from_ty",
  "context_lines": "        self.assertEqual(\n            e.match(left=helpers.invalidPatternMatch, right=lambda s: s + \"z\"),\n            \"foobarz\")\n\n    @given(from_type(Either))\n    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n        self.assertEqual(e, e)\n\n    @given(from_type(Either))\n    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n        self.assertTrue(e.match(left=lambda x: True, right=lambda x: True))\n\n",
  "slicing": "    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n"
 },
 "151": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "58",
  "column": "50",
  "context": "    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n        self.assertTrue(e.match(left=lambda x: Tru",
  "context_lines": "    @given(from_type(Either))\n    def test_equalsItself(self, e: Either[_L, _R]) -> None:\n        self.assertEqual(e, e)\n\n    @given(from_type(Either))\n    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n        self.assertTrue(e.match(left=lambda x: True, right=lambda x: True))\n\n    @given(from_type(Either))\n    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n        with self.assertRaises(ValueError):\n",
  "slicing": "    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n"
 },
 "152": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "62",
  "column": "50",
  "context": "    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n        with self.assertRaises(ValueError):\n      ",
  "context_lines": "    @given(from_type(Either))\n    def test_exhaustivePatternMatchSucceeds(self, e: Either[_L, _R]) -> None:\n        self.assertTrue(e.match(left=lambda x: True, right=lambda x: True))\n\n    @given(from_type(Either))\n    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n        with self.assertRaises(ValueError):\n            e.match()  # type: ignore\n\n        with self.assertRaises(ValueError):\n            e.match(left=lambda x: True)  # type: ignore\n\n",
  "slicing": "    def test_inexhaustivePatternMatchThrows(self, e: Either[_L, _R]) -> None:\n"
 },
 "153": {
  "name": "e",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_either.py",
  "lineno": "73",
  "column": "51",
  "context": "   def test_accessorsConsistentWithMatching(self, e: Either[_L, _R]) -> None:\n        if e.match(left=lambda x: False, right=lam",
  "context_lines": "            e.match(left=lambda x: True)  # type: ignore\n\n        with self.assertRaises(ValueError):\n            e.match(right=lambda x: True)  # type: ignore\n\n    @given(from_type(Either))\n    def test_accessorsConsistentWithMatching(self, e: Either[_L, _R]) -> None:\n        if e.match(left=lambda x: False, right=lambda x: True):\n            self.assertIsNotNone(e.right())\n\n            with self.assertRaises(AttributeError):\n                e.left()\n\n",
  "slicing": "    def test_accessorsConsistentWithMatching(self, e: Either[_L, _R]) -> None:\n"
 },
 "154": {
  "name": "source_file_name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_mypy_plugin.py",
  "lineno": "43",
  "column": "40",
  "context": "e-code\")\n\n    def _call_mypy_on_source_file(self, source_file_name: str) -> None:\n        print(\n            f\"Testing {source_file_",
  "context_lines": "                               readme_code,\n                           ])\n        except SystemExit:\n            self.fail(msg=\"Error during type-check of readme-code\")\n\n    def _call_mypy_on_source_file(self, source_file_name: str) -> None:\n        print(\n            f\"Testing {source_file_name} with mypy=={mypy.version.__version__}\"\n        )\n        self._call_mypy_on_path(\n",
  "slicing": "    def _call_mypy_on_source_file(self, source_file_name: str) -> None:\n"
 },
 "155": {
  "name": "testfile",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/tests/test_mypy_plugin.py",
  "lineno": "51",
  "column": "33",
  "context": "rce_file_name))\n\n    def _call_mypy_on_path(self, testfile: str) -> None:\n        try:\n            mypy.main.main(None, sys.",
  "context_lines": "        )\n        self._call_mypy_on_path(\n            os.path.join(helpers.PATH_TO_TEST_BASE_DIRECTORY, \"source_files\",\n                         source_file_name))\n\n    def _call_mypy_on_path(self, testfile: str) -> None:\n        try:\n            mypy.main.main(None, sys.stdout, sys.stderr, args=[testfile])\n        except SystemExit:\n",
  "slicing": "    def _call_mypy_on_path(self, testfile: str) -> None:\n"
 },
 "156": {
  "name": "version",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "32",
  "column": "11",
  "context": " import get_unique_redefinition_name\n\n\ndef plugin(version: str) -> Type[Plugin]:\n    \"\"\"Return plugin class depending on mypy versi",
  "context_lines": "from mypy.plugin import AnalyzeTypeContext, TypeAnalyzerPluginInterface, ClassDefContext, Plugin\nfrom mypy.semanal import set_callable_name\nfrom mypy.typevars import fill_typevars\nfrom mypy.util import get_unique_redefinition_name\n\n\ndef plugin(version: str) -> Type[Plugin]:\n    \"\"\"Return plugin class depending on mypy version.\"\"\"\n    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n    assert Decimal(raw_version) >= Decimal(\"0.711\")\n    return ADTPlugin\n\n\n",
  "slicing": "def plugin(version: str) -> Type[Plugin]:\n"
 },
 "157": {
  "name": "x",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "41",
  "column": "17",
  "context": "\n# These are compatibility shims\ndef get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.fullname\n    if callable(fn):\n        r",
  "context_lines": "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n    return ADTPlugin\n\n\n# fullname and name became properties with https://github.com/python/mypy/pull/7829\n# These are compatibility shims\ndef get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.fullname\n    if callable(fn):\n        return typing.cast(str, fn())\n    return typing.cast(str, fn)\n\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "def get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "    api: TypeAnalyzerPluginInterface = type_context.api\n",
   "    type_to_convert: mypy.types.UnboundType = type_context.type\n",
   "    call_args = type_to_convert.args\n",
   "    function_type = type_context.api.named_type(\"builtins.function\", [])\n",
   "    arg_types = list(map(api.analyze_type, call_args))\n",
   "    arg_kinds = [mypy.types.ARG_POS for _ in call_args]\n",
   "    arg_names = [None for _ in call_args]\n",
   "    return_type = api.named_type(\"adt.CaseConstructor\", arg_types)\n",
   "        arg_types=arg_types,\n",
   "        arg_kinds=arg_kinds,\n",
   "        arg_names=arg_names,\n",
   "        ret_type=return_type,\n",
   "        fallback=function_type,\n",
   "    context: ClassDefContext\n",
   "    name: str\n",
   "    types: List[mypy.types.Type]\n",
   "        self.context = context\n",
   "        self.name = name\n",
   "        self.types = self._normalize_types(types)\n",
   "        if len(types) != 1:\n",
   "            return types\n",
   "        t = types[0]\n",
   "        if isinstance(t, mypy.types.TupleType):\n",
   "            return t.items\n",
   "        elif isinstance(t, mypy.types.NoneType):\n",
   "            return types\n",
   "            Argument(variable=Var(f'_{i}', t),\n",
   "                     type_annotation=t,\n",
   "                     kind=ARG_POS) for i, t in enumerate(self.types)\n",
   "        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n",
   "        argNames = list(itertools.repeat(None, len(self.types)))\n",
   "            self.types, argKinds, argNames, return_type,\n",
   "        typeStr = \", \".join((str(t) for t in self.types))\n",
   "        return f'{self.name}: Case[{typeStr}]'\n",
   "    cls = context.cls\n",
   "    instanceType = fill_typevars(cls.info)\n",
   "    assert isinstance(instanceType, mypy.types.Instance)\n",
   "    cases = _get_and_delete_cases(context)\n",
   "    if cases is None:  # Cases were not successfully deleted. We need to defer\n",
   "        context.api.defer()\n",
   "    for case in cases:\n",
   "        _add_constructor_for_case(context, case, selfType=instanceType)\n",
   "        _add_accessor_for_case(context, case)\n",
   "    _add_match(context, cases)\n",
   "    cls = context.cls\n",
   "    caseDefs: List[_CaseDef] = []\n",
   "    removed: List[int] = []\n",
   "    for i, statement in enumerate(cls.defs.body):\n",
   "        if not (isinstance(statement, AssignmentStmt)\n",
   "                and statement.new_syntax):\n",
   "        lval = statement.lvalues[0]\n",
   "        if not isinstance(lval, NameExpr):\n",
   "        sym = cls.info.names.get(lval.name)\n",
   "        if sym is None:\n",
   "        var = sym.node\n",
   "        if isinstance(var, PlaceholderNode):\n",
   "        assert isinstance(var, Var)\n",
   "        assert isinstance(var.type, mypy.types.CallableType)\n",
   "        assert isinstance(var.type.ret_type, mypy.types.Instance)\n",
   "            var.type.ret_type.type) == \"adt.case.CaseConstructor\"\n",
   "        caseDefs.append(\n",
   "            _CaseDef(context=context,\n",
   "                     name=get_name(var),\n",
   "                     types=var.type.ret_type.args))\n",
   "        removed.append(i)\n",
   "    for i in reversed(removed):\n",
   "        del cls.defs.body[i]\n",
   "    return caseDefs\n",
   "    _add_method(context,\n",
   "                name=case.name,\n",
   "                args=case.constructor_args(),\n",
   "    _add_method(context,\n",
   "                name=case.name.lower(),\n",
   "                return_type=case.accessor_return())\n",
   "    matchResultType = _add_typevar(context, '_MatchResult')\n",
   "    caseCallables = {\n",
   "        case: _callable_type_for_adt_case(context,\n",
   "                                          case,\n",
   "                                          resultType=matchResultType)\n",
   "        for case in cases\n",
   "    matchArgs = [\n",
   "        Argument(variable=Var(case.name.lower(), callableType),\n",
   "        for case, callableType in caseCallables.items()\n",
   "    _add_method(context,\n",
   "                args=matchArgs,\n",
   "                return_type=mypy.types.TypeVarType(matchResultType),\n",
   "                tvar_def=matchResultType)\n",
   "    typeInfo = context.cls.info\n",
   "    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n",
   "    objectType = context.api.named_type('__builtins__.object')\n",
   "    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
   "    typeInfo.names[tVarName] = SymbolTableNode(MDEF, tVarExpr)\n",
   "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n",
   "                                 objectType)\n",
   "    callableType = case.match_lambda(\n",
   "    callableType.variables = [resultType]\n",
   "    return callableType\n",
   "    info = ctx.cls.info\n",
   "    if name in info.names:\n",
   "        sym = info.names[name]\n",
   "        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n",
   "            ctx.cls.defs.body.remove(sym.node)\n",
   "        first = Argument(\n",
   "        self_type = self_type or fill_typevars(info)\n",
   "        first = Argument(Var('self'), self_type, None, ARG_POS)\n",
   "    args = [first] + args\n",
   "    function_type = ctx.api.named_type('__builtins__.function')\n",
   "    arg_types, arg_names, arg_kinds = [], [], []\n",
   "    for arg in args:\n",
   "        assert arg.type_annotation, 'All arguments must be fully typed.'\n",
   "        arg_types.append(arg.type_annotation)\n",
   "        arg_names.append(get_name(arg.variable))\n",
   "        arg_kinds.append(arg.kind)\n",
   "    signature = mypy.types.CallableType(arg_types, arg_kinds, arg_names,\n",
   "                                        return_type, function_type)\n",
   "        signature.variables = [tvar_def]\n",
   "    func = FuncDef(name, args, Block([PassStmt()]))\n",
   "    func.info = info\n",
   "    func.is_class = is_classmethod\n",
   "    func.type = set_callable_name(signature, func)\n",
   "    func._fullname = get_fullname(info) + '.' + name\n",
   "    func.line = info.line\n",
   "    if name in info.names:\n",
   "        r_name = get_unique_redefinition_name(name, info.names)\n",
   "        info.names[r_name] = info.names[name]\n",
   "    info.defn.defs.body.append(func)\n",
   "    info.names[name] = SymbolTableNode(MDEF, func, plugin_generated=True)\n"
  ]
 },
 "158": {
  "name": "x",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "48",
  "column": "13",
  "context": "))\n    return typing.cast(str, fn)\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.name\n    if callable(fn):\n        retur",
  "context_lines": "    fn = x.fullname\n    if callable(fn):\n        return typing.cast(str, fn())\n    return typing.cast(str, fn)\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    fn = x.name\n    if callable(fn):\n        return typing.cast(str, fn())\n    return fn\n\n\n",
  "slicing": [
   "    raw_version = version.split(\"+\", 1)[0]  # Handle development versions\n",
   "    assert Decimal(raw_version) >= Decimal(\"0.711\")\n",
   "    fn = x.fullname\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return typing.cast(str, fn)\n",
   "def get_name(x: Union[FuncBase, SymbolNode]) -> str:\n",
   "    fn = x.name\n",
   "    if callable(fn):\n",
   "        return typing.cast(str, fn())\n",
   "    return fn\n",
   "                     name=get_name(var),\n"
  ]
 },
 "159": {
  "name": "fullname",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "60",
  "column": "18",
  "context": "\n    def get_type_analyze_hook(\n            self, fullname: str\n    ) -> Optional[Callable[[AnalyzeTypeContext], m",
  "context_lines": "class ADTPlugin(Plugin):\n    # Fully-qualified name for @adt\n    _ADT_DECORATOR = 'adt.decorator.adt'\n\n    def get_type_analyze_hook(\n            self, fullname: str\n    ) -> Optional[Callable[[AnalyzeTypeContext], mypy.types.Type]]:\n        if fullname == \"adt.case.Case\":\n            return _convert_case_type\n        return None\n\n",
  "slicing": "            self, fullname: str\n"
 },
 "160": {
  "name": "fullname",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "68",
  "column": "12",
  "context": "ass_decorator_hook(\n            self,\n            fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n        if fullname != self._ADT_DECORATOR:\n      ",
  "context_lines": "            return _convert_case_type\n        return None\n\n    def get_class_decorator_hook(\n            self,\n            fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n        if fullname != self._ADT_DECORATOR:\n            return None\n\n        return _transform_class\n\n\ndef _convert_case_type(type_context: AnalyzeTypeContext) -> mypy.types.Type:\n",
  "slicing": "            fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n"
 },
 "161": {
  "name": "type_context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "75",
  "column": "23",
  "context": " return _transform_class\n\n\ndef _convert_case_type(type_context: AnalyzeTypeContext) -> mypy.types.Type:\n    \"\"\"Convert Case[..] type to CaseConstructor[..",
  "context_lines": "            fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n        if fullname != self._ADT_DECORATOR:\n            return None\n\n        return _transform_class\n\n\ndef _convert_case_type(type_context: AnalyzeTypeContext) -> mypy.types.Type:\n    \"\"\"Convert Case[..] type to CaseConstructor[..]\"\"\"\n    # We do this because the semantic analyzer runs before the class_decorator_hook\n    # gets a chance to remove the Cases. This will convert the type into a valid\n    # runtime type and allows the class_decorator hook to be executed. The hook\n",
  "slicing": "def _convert_case_type(type_context: AnalyzeTypeContext) -> mypy.types.Type:\n"
 },
 "162": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "107",
  "column": "23",
  "context": "es: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n  ",
  "context_lines": "class _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n        self.name = name\n        self.types = self._normalize_types(types)\n",
  "slicing": "    def __init__(self, context: ClassDefContext, name: str,\n"
 },
 "163": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "107",
  "column": "49",
  "context": "\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n  ",
  "context_lines": "class _CaseDef:\n    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n        self.name = name\n        self.types = self._normalize_types(types)\n",
  "slicing": "    def __init__(self, context: ClassDefContext, name: str,\n"
 },
 "164": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "108",
  "column": "17",
  "context": "ext: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n        self.name =",
  "context_lines": "    context: ClassDefContext\n    name: str\n    types: List[mypy.types.Type]\n\n    def __init__(self, context: ClassDefContext, name: str,\n                 types: List[mypy.types.Type]):\n        self.context = context\n        self.name = name\n        self.types = self._normalize_types(types)\n        super().__init__()\n\n",
  "slicing": "                 types: List[mypy.types.Type]):\n"
 },
 "165": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "115",
  "column": "25",
  "context": "t__()\n\n    @staticmethod\n    def _normalize_types(types: List[mypy.types.Type]\n                         ) -> List[mypy.types.Type",
  "context_lines": "        self.name = name\n        self.types = self._normalize_types(types)\n        super().__init__()\n\n    @staticmethod\n    def _normalize_types(types: List[mypy.types.Type]\n                         ) -> List[mypy.types.Type]:\n        if len(types) != 1:\n            return types\n\n        t = types[0]\n\n",
  "slicing": "    def _normalize_types(types: List[mypy.types.Type]\n"
 },
 "166": {
  "name": "return_type",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "149",
  "column": "21",
  "context": "\n\n    def match_lambda(self,\n                     return_type: mypy.types.Type) -> mypy.types.CallableType:\n        argKinds = list(itertools.repeat(ARG_POS, ",
  "context_lines": "        else:\n            return mypy.types.TupleType(\n                self.types, self.context.api.named_type('__builtins__.tuple'))\n\n    def match_lambda(self,\n                     return_type: mypy.types.Type) -> mypy.types.CallableType:\n        argKinds = list(itertools.repeat(ARG_POS, len(self.types)))\n        argNames = list(itertools.repeat(None, len(self.types)))\n\n        return mypy.types.CallableType(\n            self.types, argKinds, argNames, return_type,\n",
  "slicing": "                     return_type: mypy.types.Type) -> mypy.types.CallableType:\n"
 },
 "167": {
  "name": "other",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "160",
  "column": "21",
  "context": "     return hash(self.name)\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, _CaseDef):\n      ",
  "context_lines": "            self.types, argKinds, argNames, return_type,\n            self.context.api.named_type('__builtins__.function'))\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, _CaseDef):\n            return False\n\n        return self.name == other.name and self.types == other.types\n\n    def __repr__(self) -> str:\n",
  "slicing": "    def __eq__(self, other: Any) -> bool:\n"
 },
 "168": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "174",
  "column": "21",
  "context": "lf.name}: Case[{typeStr}]'\n\n\ndef _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typ",
  "context_lines": "        return f'_CaseDef(name={self.name}, types={self.types!r})'\n\n    def __str__(self) -> str:\n        typeStr = \", \".join((str(t) for t in self.types))\n        return f'{self.name}: Case[{typeStr}]'\n\n\ndef _transform_class(context: ClassDefContext) -> None:\n    cls = context.cls\n\n    instanceType = fill_typevars(cls.info)\n    assert isinstance(instanceType, mypy.types.Instance)\n\n    cases = _get_and_delete_cases(context)\n",
  "slicing": "def _transform_class(context: ClassDefContext) -> None:\n"
 },
 "169": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "195",
  "column": "26",
  "context": "by constructor methods.\ndef _get_and_delete_cases(context: ClassDefContext\n                          ) -> Optional[List[_Case",
  "context_lines": "    _add_match(context, cases)\n\n\n# Returns ADT cases which were listed as class variables (similar to\n# cls.__annotations__ at runtime), and removes those variables from\n# typechecking, as they will be replaced by constructor methods.\ndef _get_and_delete_cases(context: ClassDefContext\n                          ) -> Optional[List[_CaseDef]]:\n    \"\"\"Search the class body for adt's Case constructions and delete them\n\n    For a given context, search the class body for assignments of the form\n    `CASENAME: Case[...]`. Delete them, and return a _CaseDef for each.\n\n",
  "slicing": "def _get_and_delete_cases(context: ClassDefContext\n"
 },
 "170": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "255",
  "column": "30",
  "context": "er case (uppercase)\ndef _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n                              selfType: mypy.types",
  "context_lines": "    for i in reversed(removed):\n        del cls.defs.body[i]\n\n    return caseDefs\n\n\n# Class constructor method per case (uppercase)\ndef _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n                              selfType: mypy.types.Instance) -> None:\n    _add_method(context,\n                name=case.name,\n                args=case.constructor_args(),\n",
  "slicing": "def _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n"
 },
 "171": {
  "name": "case",
  "type": "_CaseDef",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "255",
  "column": "56",
  "context": "dd_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n                              selfType: mypy.types",
  "context_lines": "    for i in reversed(removed):\n        del cls.defs.body[i]\n\n    return caseDefs\n\n\n# Class constructor method per case (uppercase)\ndef _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n                              selfType: mypy.types.Instance) -> None:\n    _add_method(context,\n                name=case.name,\n                args=case.constructor_args(),\n",
  "slicing": "def _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n"
 },
 "172": {
  "name": "selfType",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "256",
  "column": "30",
  "context": "xt, case: _CaseDef,\n                              selfType: mypy.types.Instance) -> None:\n    _add_method(context,\n                name=case",
  "context_lines": "        del cls.defs.body[i]\n\n    return caseDefs\n\n\n# Class constructor method per case (uppercase)\ndef _add_constructor_for_case(context: ClassDefContext, case: _CaseDef,\n                              selfType: mypy.types.Instance) -> None:\n    _add_method(context,\n                name=case.name,\n                args=case.constructor_args(),\n                return_type=selfType,\n",
  "slicing": "                              selfType: mypy.types.Instance) -> None:\n"
 },
 "173": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "265",
  "column": "27",
  "context": "d per case (lowercase)\ndef _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n    _add_method(context,\n                name=case",
  "context_lines": "                args=case.constructor_args(),\n                return_type=selfType,\n                is_classmethod=True)\n\n\n# Accessor method per case (lowercase)\ndef _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n    _add_method(context,\n                name=case.name.lower(),\n                args=[],\n                return_type=case.accessor_return())\n\n\n",
  "slicing": "def _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n"
 },
 "174": {
  "name": "case",
  "type": "_CaseDef",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "265",
  "column": "53",
  "context": " _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n    _add_method(context,\n                name=case",
  "context_lines": "                args=case.constructor_args(),\n                return_type=selfType,\n                is_classmethod=True)\n\n\n# Accessor method per case (lowercase)\ndef _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n    _add_method(context,\n                name=case.name.lower(),\n                args=[],\n                return_type=case.accessor_return())\n\n\n",
  "slicing": "def _add_accessor_for_case(context: ClassDefContext, case: _CaseDef) -> None:\n"
 },
 "175": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "273",
  "column": "15",
  "context": "tching (uses lowercase case names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_Matc",
  "context_lines": "                name=case.name.lower(),\n                args=[],\n                return_type=case.accessor_return())\n\n\n# `match` method for pattern matching (uses lowercase case names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_type_for_adt_case(context,\n                                          case,\n",
  "slicing": "def _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n"
 },
 "176": {
  "name": "cases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "273",
  "column": "41",
  "context": "e names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_Matc",
  "context_lines": "                name=case.name.lower(),\n                args=[],\n                return_type=case.accessor_return())\n\n\n# `match` method for pattern matching (uses lowercase case names)\ndef _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n    matchResultType = _add_typevar(context, '_MatchResult')\n\n    caseCallables = {\n        case: _callable_type_for_adt_case(context,\n                                          case,\n",
  "slicing": "def _add_match(context: ClassDefContext, cases: Iterable[_CaseDef]) -> None:\n"
 },
 "177": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "300",
  "column": "17",
  "context": "n the\n# body of the given class.\ndef _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.Type",
  "context_lines": "                return_type=mypy.types.TypeVarType(matchResultType),\n                tvar_def=matchResultType)\n\n\n# Generates a new, unique, unbounded type variable and defines it within the\n# body of the given class.\ndef _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n",
  "slicing": "def _add_typevar(context: ClassDefContext,\n"
 },
 "178": {
  "name": "tVarName",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "301",
  "column": "17",
  "context": "ypevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedN",
  "context_lines": "                tvar_def=matchResultType)\n\n\n# Generates a new, unique, unbounded type variable and defines it within the\n# body of the given class.\ndef _add_typevar(context: ClassDefContext,\n                 tVarName: str) -> mypy.types.TypeVarDef:\n    typeInfo = context.cls.info\n    tVarQualifiedName = f'{get_fullname(typeInfo)}.{tVarName}'\n    objectType = context.api.named_type('__builtins__.object')\n\n    tVarExpr = TypeVarExpr(tVarName, tVarQualifiedName, [], objectType)\n",
  "slicing": "                 tVarName: str) -> mypy.types.TypeVarDef:\n"
 },
 "179": {
  "name": "context",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "315",
  "column": "32",
  "context": "cribed by `case`.\ndef _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.t",
  "context_lines": "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n                                 objectType)\n\n\n# Determines the Callable type appropriate for destructuring the ADT case\n# described by `case`.\ndef _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.types.TypeVarDef\n                                ) -> mypy.types.CallableType:\n    callableType = case.match_lambda(\n        return_type=mypy.types.TypeVarType(resultType))\n",
  "slicing": "def _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n"
 },
 "180": {
  "name": "case",
  "type": "_CaseDef",
  "class": "customized",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "315",
  "column": "58",
  "context": "lable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.t",
  "context_lines": "    return mypy.types.TypeVarDef(tVarName, tVarQualifiedName, -1, [],\n                                 objectType)\n\n\n# Determines the Callable type appropriate for destructuring the ADT case\n# described by `case`.\ndef _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.types.TypeVarDef\n                                ) -> mypy.types.CallableType:\n    callableType = case.match_lambda(\n        return_type=mypy.types.TypeVarType(resultType))\n",
  "slicing": "def _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n"
 },
 "181": {
  "name": "resultType",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "316",
  "column": "32",
  "context": ", case: _CaseDef,\n                                resultType: mypy.types.TypeVarDef\n                                ) -> mypy.types.Ca",
  "context_lines": "                                 objectType)\n\n\n# Determines the Callable type appropriate for destructuring the ADT case\n# described by `case`.\ndef _callable_type_for_adt_case(context: ClassDefContext, case: _CaseDef,\n                                resultType: mypy.types.TypeVarDef\n                                ) -> mypy.types.CallableType:\n    callableType = case.match_lambda(\n        return_type=mypy.types.TypeVarType(resultType))\n    callableType.variables = [resultType]\n",
  "slicing": "                                resultType: mypy.types.TypeVarDef\n"
 },
 "182": {
  "name": "ctx",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "329",
  "column": "8",
  "context": "2b1d6c5c3acc55a/LICENSE.\ndef _add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n ",
  "context_lines": "#\n# See original code at https://github.com/python/mypy/blob/17b68c6b7eaa76853422544e32b1d6c5c3acc55a/mypy/plugins/common.py#L81,\n# and license at https://github.com/python/mypy/blob/17b68c6b7eaa76853422544e32b1d6c5c3acc55a/LICENSE.\ndef _add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n",
  "slicing": "        ctx: ClassDefContext,\n"
 },
 "183": {
  "name": "name",
  "type": "str",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "330",
  "column": "8",
  "context": "add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type:",
  "context_lines": "# See original code at https://github.com/python/mypy/blob/17b68c6b7eaa76853422544e32b1d6c5c3acc55a/mypy/plugins/common.py#L81,\n# and license at https://github.com/python/mypy/blob/17b68c6b7eaa76853422544e32b1d6c5c3acc55a/LICENSE.\ndef _add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n",
  "slicing": "        name: str,\n"
 },
 "184": {
  "name": "args",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "331",
  "column": "8",
  "context": " ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self",
  "context_lines": "# and license at https://github.com/python/mypy/blob/17b68c6b7eaa76853422544e32b1d6c5c3acc55a/LICENSE.\ndef _add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n",
  "slicing": "        args: List[Argument],\n"
 },
 "185": {
  "name": "return_type",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "332",
  "column": "8",
  "context": " name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = Non",
  "context_lines": "def _add_method(\n        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n",
  "slicing": "        return_type: mypy.types.Type,\n"
 },
 "186": {
  "name": "self_type",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "333",
  "column": "8",
  "context": "t],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] ",
  "context_lines": "        ctx: ClassDefContext,\n        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n    \"\"\"Adds a new method to a class.\n",
  "slicing": "        self_type: Optional[mypy.types.Type] = None,\n"
 },
 "187": {
  "name": "tvar_def",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "334",
  "column": "8",
  "context": "f_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n ",
  "context_lines": "        name: str,\n        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n    \"\"\"Adds a new method to a class.\n    \"\"\"\n",
  "slicing": "        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n"
 },
 "188": {
  "name": "is_classmethod",
  "type": "bool",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/mypy_plugin.py",
  "lineno": "335",
  "column": "8",
  "context": ": Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n    \"\"\"Adds a new method to a class.\n  ",
  "context_lines": "        args: List[Argument],\n        return_type: mypy.types.Type,\n        self_type: Optional[mypy.types.Type] = None,\n        tvar_def: Optional[mypy.types.TypeVarDef] = None,\n        is_classmethod: bool = False,\n) -> None:\n    \"\"\"Adds a new method to a class.\n    \"\"\"\n    info = ctx.cls.info\n\n",
  "slicing": "        is_classmethod: bool = False,\n"
 },
 "189": {
  "name": "types",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "8",
  "column": "23",
  "context": "\n\n\nclass TupleConstructor:\n    def __init__(self, types: Tuple[Type[Any], ...]):\n        self._types = types\n        super().__init",
  "context_lines": "from typing import TYPE_CHECKING, Any, Callable, Generic, Tuple, Type, TypeVar, Union\n\n_T = TypeVar('_T')\n_U = TypeVar('_U')\n\n\nclass TupleConstructor:\n    def __init__(self, types: Tuple[Type[Any], ...]):\n        self._types = types\n        super().__init__()\n\n    def constructCase(self, *args: Any) -> Tuple[Any, ...]:\n        assert len(args) == len(self._types)\n",
  "slicing": "    def __init__(self, types: Tuple[Type[Any], ...]):\n"
 },
 "190": {
  "name": "value",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "16",
  "column": "30",
  "context": "  return (*args, )\n\n    def deconstructCase(self, value: Tuple[Any, ...],\n                        callback: Callable[..., _T",
  "context_lines": "        super().__init__()\n\n    def constructCase(self, *args: Any) -> Tuple[Any, ...]:\n        assert len(args) == len(self._types)\n        return (*args, )\n\n    def deconstructCase(self, value: Tuple[Any, ...],\n                        callback: Callable[..., _T]) -> _T:\n        assert len(value) == len(self._types)\n        return callback(*value)\n\n    def getTypes(self) -> Any:\n",
  "slicing": "    def deconstructCase(self, value: Tuple[Any, ...],\n"
 },
 "191": {
  "name": "callback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "17",
  "column": "24",
  "context": ", value: Tuple[Any, ...],\n                        callback: Callable[..., _T]) -> _T:\n        assert len(value) == len(self._types)\n    ",
  "context_lines": "    def constructCase(self, *args: Any) -> Tuple[Any, ...]:\n        assert len(args) == len(self._types)\n        return (*args, )\n\n    def deconstructCase(self, value: Tuple[Any, ...],\n                        callback: Callable[..., _T]) -> _T:\n        assert len(value) == len(self._types)\n        return callback(*value)\n\n    def getTypes(self) -> Any:\n        return self._types\n\n",
  "slicing": "                        callback: Callable[..., _T]) -> _T:\n"
 },
 "192": {
  "name": "argType",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "30",
  "column": "23",
  "context": "class IdentityConstructor:\n    def __init__(self, argType: Type[Any]):\n        self._argType = argType\n        super().__",
  "context_lines": "    def __repr__(self) -> str:\n        typeString = ', '.join((str(t) for t in self._types))\n        return f'Case[{typeString}]'\n\n\nclass IdentityConstructor:\n    def __init__(self, argType: Type[Any]):\n        self._argType = argType\n        super().__init__()\n\n    def constructCase(self, arg: _T) -> _T:\n        return arg\n\n",
  "slicing": "    def __init__(self, argType: Type[Any]):\n"
 },
 "193": {
  "name": "arg",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "34",
  "column": "28",
  "context": "  super().__init__()\n\n    def constructCase(self, arg: _T) -> _T:\n        return arg\n\n    def deconstructCase(self, ",
  "context_lines": "class IdentityConstructor:\n    def __init__(self, argType: Type[Any]):\n        self._argType = argType\n        super().__init__()\n\n    def constructCase(self, arg: _T) -> _T:\n        return arg\n\n    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n        return callback(value)\n\n    def getTypes(self) -> Any:\n",
  "slicing": "    def constructCase(self, arg: _T) -> _T:\n"
 },
 "194": {
  "name": "value",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "37",
  "column": "30",
  "context": "        return arg\n\n    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n        return callback(value)\n\n    def getTypes(s",
  "context_lines": "        self._argType = argType\n        super().__init__()\n\n    def constructCase(self, arg: _T) -> _T:\n        return arg\n\n    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n        return callback(value)\n\n    def getTypes(self) -> Any:\n        return self._argType\n\n    def __repr__(self) -> str:\n",
  "slicing": "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n"
 },
 "195": {
  "name": "callback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "37",
  "column": "41",
  "context": "urn arg\n\n    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n        return callback(value)\n\n    def getTypes(s",
  "context_lines": "        self._argType = argType\n        super().__init__()\n\n    def constructCase(self, arg: _T) -> _T:\n        return arg\n\n    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n        return callback(value)\n\n    def getTypes(self) -> Any:\n        return self._argType\n\n    def __repr__(self) -> str:\n",
  "slicing": "    def deconstructCase(self, value: _T, callback: Callable[[_T], _U]) -> _U:\n"
 },
 "196": {
  "name": "value",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "54",
  "column": "30",
  "context": "       return None\n\n    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n        return callback()\n\n    def getTypes(self) ",
  "context_lines": "    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n                           TupleConstructor]\n\n    def constructCase(self) -> None:\n        return None\n\n    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n        return callback()\n\n    def getTypes(self) -> None:\n        return None\n\n    def __getitem__(self, params: Union[None, Type[Any], Tuple[Type[Any], ...]]\n",
  "slicing": "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n"
 },
 "197": {
  "name": "callback",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "54",
  "column": "43",
  "context": " None\n\n    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n        return callback()\n\n    def getTypes(self) ",
  "context_lines": "    AnyConstructor = Union[\"CaseConstructor\", IdentityConstructor,\n                           TupleConstructor]\n\n    def constructCase(self) -> None:\n        return None\n\n    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n        return callback()\n\n    def getTypes(self) -> None:\n        return None\n\n    def __getitem__(self, params: Union[None, Type[Any], Tuple[Type[Any], ...]]\n",
  "slicing": "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n"
 },
 "198": {
  "name": "params",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "60",
  "column": "26",
  "context": "e:\n        return None\n\n    def __getitem__(self, params: Union[None, Type[Any], Tuple[Type[Any], ...]]\n                    ) -> AnyConstructor:\n        i",
  "context_lines": "    def deconstructCase(self, value: None, callback: Callable[[], _T]) -> _T:\n        return callback()\n\n    def getTypes(self) -> None:\n        return None\n\n    def __getitem__(self, params: Union[None, Type[Any], Tuple[Type[Any], ...]]\n                    ) -> AnyConstructor:\n        if params is None:\n            return self\n        elif isinstance(params, tuple):\n",
  "slicing": "    def __getitem__(self, params: Union[None, Type[Any], Tuple[Type[Any], ...]]\n"
 },
 "199": {
  "name": "params",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/case.py",
  "lineno": "79",
  "column": "30",
  "context": "ass CaseMeta(type):\n        def __getitem__(self, params: _T) -> CaseT[_T]:\n            pass\n\n    class Case(CaseT[None], meta",
  "context_lines": "    # Simple shim to capture the type arguments for use in the mypy plugin\n    class CaseT(Generic[_T]):\n        pass\n\n    class CaseMeta(type):\n        def __getitem__(self, params: _T) -> CaseT[_T]:\n            pass\n\n    class Case(CaseT[None], metaclass=CaseMeta):\n        pass\nelse:\n",
  "slicing": "        def __getitem__(self, params: _T) -> CaseT[_T]:\n"
 },
 "200": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "Pysonar2",
  "file_path": "adt/adt/decorator.py",
  "lineno": "9",
  "column": "8",
  "context": "e import CaseConstructor\n\n\n@no_type_check\ndef adt(cls):\n    try:\n        annotations = cls.__annotations__",
  "context_lines": "from enum import Enum\nfrom typing import Any, Callable, Type, TypeVar, no_type_check\n\nfrom adt.case import CaseConstructor\n\n\n@no_type_check\ndef adt(cls):\n    try:\n        annotations = cls.__annotations__\n    except AttributeError:\n        # no annotations defined\n",
  "slicing": "def adt(cls):\n"
 },
 "201": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "45",
  "column": "17",
  "context": "(cls, cls._Key)\n    return cls\n\n\ndef _installInit(cls: Any) -> None:\n    def _init(self: Any,\n              key: Enum,\n",
  "context_lines": "        _installOneConstructor(cls, caseKey)\n        _installOneAccessor(cls, caseKey)\n\n    _installMatch(cls, cls._Key)\n    return cls\n\n\ndef _installInit(cls: Any) -> None:\n    def _init(self: Any,\n              key: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n",
  "slicing": "def _installInit(cls: Any) -> None:\n"
 },
 "202": {
  "name": "key",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "47",
  "column": "14",
  "context": ") -> None:\n    def _init(self: Any,\n              key: Enum,\n              value: Any,\n              orig_init:",
  "context_lines": "    _installMatch(cls, cls._Key)\n    return cls\n\n\ndef _installInit(cls: Any) -> None:\n    def _init(self: Any,\n              key: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n        self._key = key\n        self._value = value\n",
  "slicing": "              key: Enum,\n"
 },
 "203": {
  "name": "value",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "48",
  "column": "14",
  "context": "self: Any,\n              key: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = c",
  "context_lines": "    return cls\n\n\ndef _installInit(cls: Any) -> None:\n    def _init(self: Any,\n              key: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n        self._key = key\n        self._value = value\n        orig_init(self)\n\n",
  "slicing": "              value: Any,\n"
 },
 "204": {
  "name": "orig_init",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "49",
  "column": "14",
  "context": "ey: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n        self._key = key\n        self._value = valu",
  "context_lines": "def _installInit(cls: Any) -> None:\n    def _init(self: Any,\n              key: Enum,\n              value: Any,\n              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n        self._key = key\n        self._value = value\n        orig_init(self)\n\n    cls.__init__ = _init\n\n\n",
  "slicing": "              orig_init: Callable[[Any], None] = cls.__init__) -> None:\n"
 },
 "205": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "57",
  "column": "17",
  "context": "elf)\n\n    cls.__init__ = _init\n\n\ndef _installRepr(cls: Any) -> None:\n    def _repr(self: Any) -> str:\n        return f'",
  "context_lines": "        self._key = key\n        self._value = value\n        orig_init(self)\n\n    cls.__init__ = _init\n\n\ndef _installRepr(cls: Any) -> None:\n    def _repr(self: Any) -> str:\n        return f'{type(self)}.{self._key.name}({self._value})'\n\n    if '__repr__' not in cls.__dict__:\n        cls.__repr__ = _repr\n\n\n",
  "slicing": "def _installRepr(cls: Any) -> None:\n"
 },
 "206": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "65",
  "column": "16",
  "context": "_:\n        cls.__repr__ = _repr\n\n\ndef _installStr(cls: Any) -> None:\n    def _str(self: Any) -> str:\n        return f'<",
  "context_lines": "    def _repr(self: Any) -> str:\n        return f'{type(self)}.{self._key.name}({self._value})'\n\n    if '__repr__' not in cls.__dict__:\n        cls.__repr__ = _repr\n\n\ndef _installStr(cls: Any) -> None:\n    def _str(self: Any) -> str:\n        return f'<{type(self)}.{self._key.name}: {self._value}>'\n\n    if '__str__' not in cls.__dict__:\n        cls.__str__ = _str\n\n\n",
  "slicing": "def _installStr(cls: Any) -> None:\n"
 },
 "207": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "73",
  "column": "15",
  "context": "ct__:\n        cls.__str__ = _str\n\n\ndef _installEq(cls: Any) -> None:\n    # It's important to capture `cls` here, instea",
  "context_lines": "    def _str(self: Any) -> str:\n        return f'<{type(self)}.{self._key.name}: {self._value}>'\n\n    if '__str__' not in cls.__dict__:\n        cls.__str__ = _str\n\n\ndef _installEq(cls: Any) -> None:\n    # It's important to capture `cls` here, instead of using type(self), to\n    # preserve covariance; i.e., if `self` and `other` are instances of\n    # different descendants of `cls`, it's irrelevant for this particular\n    # equality check and we shouldn't rule it out (that should be the job of\n",
  "slicing": "def _installEq(cls: Any) -> None:\n"
 },
 "208": {
  "name": "other",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "79",
  "column": "23",
  "context": "implementation of __eq__).\n    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n        if not isinstance(other, cls):\n           ",
  "context_lines": "    # preserve covariance; i.e., if `self` and `other` are instances of\n    # different descendants of `cls`, it's irrelevant for this particular\n    # equality check and we shouldn't rule it out (that should be the job of\n    # further-derived classes' implementation of __eq__).\n    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n        if not isinstance(other, cls):\n            return False\n\n        return bool(self._key == other._key and self._value == other._value)\n\n    if '__eq__' not in cls.__dict__:\n",
  "slicing": "    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n"
 },
 "209": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "79",
  "column": "35",
  "context": "on of __eq__).\n    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n        if not isinstance(other, cls):\n           ",
  "context_lines": "    # preserve covariance; i.e., if `self` and `other` are instances of\n    # different descendants of `cls`, it's irrelevant for this particular\n    # equality check and we shouldn't rule it out (that should be the job of\n    # further-derived classes' implementation of __eq__).\n    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n        if not isinstance(other, cls):\n            return False\n\n        return bool(self._key == other._key and self._value == other._value)\n\n    if '__eq__' not in cls.__dict__:\n",
  "slicing": "    def _eq(self: Any, other: Any, cls: Type[Any] = cls) -> bool:\n"
 },
 "210": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "89",
  "column": "27",
  "context": "    cls.__eq__ = _eq\n\n\ndef _installOneConstructor(cls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _c",
  "context_lines": "            return False\n\n        return bool(self._key == other._key and self._value == other._value)\n\n    if '__eq__' not in cls.__dict__:\n        cls.__eq__ = _eq\n\n\ndef _installOneConstructor(cls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _case: Enum = case) -> Any:\n        return cls(key=_case,\n                   value=cls.__annotations__[_case.name].constructCase(*args))\n\n    if hasattr(cls, case.name):\n",
  "slicing": "def _installOneConstructor(cls: Any, case: Enum) -> None:\n"
 },
 "211": {
  "name": "case",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "89",
  "column": "37",
  "context": "eq__ = _eq\n\n\ndef _installOneConstructor(cls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _c",
  "context_lines": "            return False\n\n        return bool(self._key == other._key and self._value == other._value)\n\n    if '__eq__' not in cls.__dict__:\n        cls.__eq__ = _eq\n\n\ndef _installOneConstructor(cls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _case: Enum = case) -> Any:\n        return cls(key=_case,\n                   value=cls.__annotations__[_case.name].constructCase(*args))\n\n    if hasattr(cls, case.name):\n",
  "slicing": "def _installOneConstructor(cls: Any, case: Enum) -> None:\n"
 },
 "212": {
  "name": "cls",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "90",
  "column": "20",
  "context": "ls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _case: Enum = case) -> Any:\n        return cls(key=_case,\n                   v",
  "context_lines": "        return bool(self._key == other._key and self._value == other._value)\n\n    if '__eq__' not in cls.__dict__:\n        cls.__eq__ = _eq\n\n\ndef _installOneConstructor(cls: Any, case: Enum) -> None:\n    def constructor(cls: Type[Any], *args: Any, _case: Enum = case) -> Any:\n        return cls(key=_case,\n                   value=cls.__annotations__[_case.name].constructCase(*args))\n\n    if hasattr(cls, case.name):\n        raise AttributeError(\n",
  "slicing": "    def constructor(cls: Type[Any], *args: Any, _case: Enum = case) -> Any:\n"
 },
 "213": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "102",
  "column": "24",
  "context": "assmethod(constructor))\n\n\ndef _installOneAccessor(cls: Any, case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) ->",
  "context_lines": "        raise AttributeError(\n            f'{cls} should not have a default value for {case.name}, as this will be a generated constructor'\n        )\n\n    setattr(cls, case.name, classmethod(constructor))\n\n\ndef _installOneAccessor(cls: Any, case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) -> Any:\n        if self._key != _case:\n            raise AttributeError(\n                f'{self} was constructed as case {self._key.name}, so {_case.name.lower()} is not accessible'\n",
  "slicing": "def _installOneAccessor(cls: Any, case: Enum) -> None:\n"
 },
 "214": {
  "name": "case",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "102",
  "column": "34",
  "context": "constructor))\n\n\ndef _installOneAccessor(cls: Any, case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) ->",
  "context_lines": "        raise AttributeError(\n            f'{cls} should not have a default value for {case.name}, as this will be a generated constructor'\n        )\n\n    setattr(cls, case.name, classmethod(constructor))\n\n\ndef _installOneAccessor(cls: Any, case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) -> Any:\n        if self._key != _case:\n            raise AttributeError(\n                f'{self} was constructed as case {self._key.name}, so {_case.name.lower()} is not accessible'\n",
  "slicing": "def _installOneAccessor(cls: Any, case: Enum) -> None:\n"
 },
 "215": {
  "name": "_case",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "103",
  "column": "28",
  "context": " case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) -> Any:\n        if self._key != _case:\n            raise A",
  "context_lines": "            f'{cls} should not have a default value for {case.name}, as this will be a generated constructor'\n        )\n\n    setattr(cls, case.name, classmethod(constructor))\n\n\ndef _installOneAccessor(cls: Any, case: Enum) -> None:\n    def accessor(self: Any, _case: Enum = case) -> Any:\n        if self._key != _case:\n            raise AttributeError(\n                f'{self} was constructed as case {self._key.name}, so {_case.name.lower()} is not accessible'\n            )\n\n",
  "slicing": "    def accessor(self: Any, _case: Enum = case) -> Any:\n"
 },
 "216": {
  "name": "cls",
  "type": "UNKNOWN",
  "class": "unknown",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "119",
  "column": "18",
  "context": "ult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Typ",
  "context_lines": "    accessorName = case.name.lower()\n    if accessorName not in cls.__dict__:\n        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n",
  "slicing": "def _installMatch(cls: Any, cases: Type[Enum]) -> None:\n"
 },
 "217": {
  "name": "cases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "119",
  "column": "28",
  "context": "Var('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Typ",
  "context_lines": "    accessorName = case.name.lower()\n    if accessorName not in cls.__dict__:\n        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n",
  "slicing": "def _installMatch(cls: Any, cases: Type[Enum]) -> None:\n"
 },
 "218": {
  "name": "_cases",
  "type": "dict",
  "class": "build-in",
  "approach": "annotation",
  "file_path": "adt/adt/decorator.py",
  "lineno": "121",
  "column": "14",
  "context": ") -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult",
  "context_lines": "        setattr(cls, accessorName, accessor)\n\n\n_MatchResult = TypeVar('_MatchResult')\n\n\ndef _installMatch(cls: Any, cases: Type[Enum]) -> None:\n    def match(self: Any,\n              _cases: Type[Enum] = cases,\n              **kwargs: Callable[..., _MatchResult]) -> _MatchResult:\n        caseNames = _cases.__members__.keys()\n        upperKeys = {k: k.upper() for k in kwargs.keys()}\n\n        for key in upperKeys.values():\n",
  "slicing": "              _cases: Type[Enum] = cases,\n"
 }
}